/* automatically generated by rust-bindgen 0.60.1 */

pub const AV_MAX_IOCTRL_DATA_SIZE: u32 = 1024;
pub const AV_MAX_AUDIO_DATA_SIZE: u32 = 1280;
pub const AV_ER_NoERROR: u32 = 0;
pub const AV_ER_INVALID_ARG: i32 = -20000;
pub const AV_ER_BUFPARA_MAXSIZE_INSUFF: i32 = -20001;
pub const AV_ER_EXCEED_MAX_CHANNEL: i32 = -20002;
pub const AV_ER_MEM_INSUFF: i32 = -20003;
pub const AV_ER_FAIL_CREATE_THREAD: i32 = -20004;
pub const AV_ER_EXCEED_MAX_ALARM: i32 = -20005;
pub const AV_ER_EXCEED_MAX_SIZE: i32 = -20006;
pub const AV_ER_SERV_NO_RESPONSE: i32 = -20007;
pub const AV_ER_CLIENT_NO_AVLOGIN: i32 = -20008;
pub const AV_ER_WRONG_VIEWACCorPWD: i32 = -20009;
pub const AV_ER_INVALID_SID: i32 = -20010;
pub const AV_ER_TIMEOUT: i32 = -20011;
pub const AV_ER_DATA_NOREADY: i32 = -20012;
pub const AV_ER_INCOMPLETE_FRAME: i32 = -20013;
pub const AV_ER_LOSED_THIS_FRAME: i32 = -20014;
pub const AV_ER_SESSION_CLOSE_BY_REMOTE: i32 = -20015;
pub const AV_ER_REMOTE_TIMEOUT_DISCONNECT: i32 = -20016;
pub const AV_ER_SERVER_EXIT: i32 = -20017;
pub const AV_ER_CLIENT_EXIT: i32 = -20018;
pub const AV_ER_NOT_INITIALIZED: i32 = -20019;
pub const AV_ER_CLIENT_NOT_SUPPORT: i32 = -20020;
pub const AV_ER_SENDIOCTRL_ALREADY_CALLED: i32 = -20021;
pub const AV_ER_SENDIOCTRL_EXIT: i32 = -20022;
pub const AV_ER_NO_PERMISSION: i32 = -20023;
pub const AV_ER_WRONG_ACCPWD_LENGTH: i32 = -20024;
pub const MAX_DEFAULT_IOTC_SESSION_NUMBER: u32 = 128;
pub const IOTC_MAX_PACKET_SIZE: u32 = 1400;
pub const MAX_CHANNEL_NUMBER: u32 = 32;
pub const IOTC_SESSION_ALIVE_TIMEOUT: u32 = 15;
pub const IOTC_ER_NoERROR: u32 = 0;
pub const IOTC_ER_SERVER_NOT_RESPONSE: i32 = -1;
pub const IOTC_ER_FAIL_RESOLVE_HOSTNAME: i32 = -2;
pub const IOTC_ER_ALREADY_INITIALIZED: i32 = -3;
pub const IOTC_ER_FAIL_CREATE_MUTEX: i32 = -4;
pub const IOTC_ER_FAIL_CREATE_THREAD: i32 = -5;
pub const IOTC_ER_FAIL_CREATE_SOCKET: i32 = -6;
pub const IOTC_ER_FAIL_SOCKET_OPT: i32 = -7;
pub const IOTC_ER_FAIL_SOCKET_BIND: i32 = -8;
pub const IOTC_ER_UNLICENSE: i32 = -10;
pub const IOTC_ER_LOGIN_ALREADY_CALLED: i32 = -11;
pub const IOTC_ER_NOT_INITIALIZED: i32 = -12;
pub const IOTC_ER_TIMEOUT: i32 = -13;
pub const IOTC_ER_INVALID_SID: i32 = -14;
pub const IOTC_ER_UNKNOWN_DEVICE: i32 = -15;
pub const IOTC_ER_FAIL_GET_LOCAL_IP: i32 = -16;
pub const IOTC_ER_LISTEN_ALREADY_CALLED: i32 = -17;
pub const IOTC_ER_EXCEED_MAX_SESSION: i32 = -18;
pub const IOTC_ER_CAN_NOT_FIND_DEVICE: i32 = -19;
pub const IOTC_ER_CONNECT_IS_CALLING: i32 = -20;
pub const IOTC_ER_SESSION_CLOSE_BY_REMOTE: i32 = -22;
pub const IOTC_ER_REMOTE_TIMEOUT_DISCONNECT: i32 = -23;
pub const IOTC_ER_DEVICE_NOT_LISTENING: i32 = -24;
pub const IOTC_ER_CH_NOT_ON: i32 = -26;
pub const IOTC_ER_FAIL_CONNECT_SEARCH: i32 = -27;
pub const IOTC_ER_MASTER_TOO_FEW: i32 = -28;
pub const IOTC_ER_AES_CERTIFY_FAIL: i32 = -29;
pub const IOTC_ER_SESSION_NO_FREE_CHANNEL: i32 = -31;
pub const IOTC_ER_TCP_TRAVEL_FAILED: i32 = -32;
pub const IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED: i32 = -33;
pub const IOTC_ER_CLIENT_NOT_SECURE_MODE: i32 = -34;
pub const IOTC_ER_CLIENT_SECURE_MODE: i32 = -35;
pub const IOTC_ER_DEVICE_NOT_SECURE_MODE: i32 = -36;
pub const IOTC_ER_DEVICE_SECURE_MODE: i32 = -37;
pub const IOTC_ER_INVALID_MODE: i32 = -38;
pub const IOTC_ER_EXIT_LISTEN: i32 = -39;
pub const IOTC_ER_NO_PERMISSION: i32 = -40;
pub const IOTC_ER_NETWORK_UNREACHABLE: i32 = -41;
pub const IOTC_ER_FAIL_SETUP_RELAY: i32 = -42;
pub const IOTC_ER_NOT_SUPPORT_RELAY: i32 = -43;
pub const IOTC_ER_NO_SERVER_LIST: i32 = -44;
pub const IOTC_ER_DEVICE_MULTI_LOGIN: i32 = -45;
pub const IOTC_ER_INVALID_ARG: i32 = -46;
pub const IOTC_ER_NOT_SUPPORT_PE: i32 = -47;
pub const IOTC_ER_DEVICE_EXCEED_MAX_SESSION: i32 = -48;
#[doc = " Used by AV clients to tell AV servers to change the time interval"]
#[doc = " of sending packets by avSendFrameData() when AV clients are too slow"]
#[doc = " to handle frame data."]
pub const AVIOCtrlType_IOTYPE_INNER_SND_DATA_DELAY: AVIOCtrlType = 255;
#[doc = " The starting enum value of user defined IO types. It is suggested"]
#[doc = " to assign this to the first one of user defined types, like <br>"]
#[doc = " enum IOTYPE_USER_DEFINED { <br>"]
#[doc = " IOTYPE_USER_PLAY = IOTYPE_USER_DEFINED_START, <br>"]
#[doc = " IOTYPE_USER_STOP <br>"]
#[doc = " }"]
pub const AVIOCtrlType_IOTYPE_USER_DEFINED_START: AVIOCtrlType = 256;
#[doc = " \\details The types for AV IO control. AV IO control are used\tfor AV servers"]
#[doc = "\t\t\tand AV clients to communicate control message with each other."]
#[doc = "\t\t\tThe types contains system defined types and user defined ones."]
#[doc = "\t\t\tThe range of system defined\ttypes is from 0x00 to 0xFF, while"]
#[doc = "\t\t\tuser defined ones is starting from 0x100."]
pub type AVIOCtrlType = ::std::os::raw::c_uint;
pub const _AV_RESET_TARGET_RESET_VIDEO: _AV_RESET_TARGET = 0;
pub const _AV_RESET_TARGET_RESET_AUDIO: _AV_RESET_TARGET = 1;
pub const _AV_RESET_TARGET_RESET_ALL: _AV_RESET_TARGET = 2;
pub type _AV_RESET_TARGET = ::std::os::raw::c_uint;
pub use self::_AV_RESET_TARGET as AV_RESET_TARGET;
#[doc = " \\details The prototype of authentication function used for an AV server."]
#[doc = "\t\t\tThe authentication function is set when an AV server starts by avServStart2()."]
#[doc = "\t\t\tThe AV server will call back authentication function when an AV"]
#[doc = "\t\t\tclient wants to connect with szViewAccount and szViewAccount"]
#[doc = " \\param szViewAccount [in] The view account provided by AV clients for authentication"]
#[doc = " \\param szViewPassword [in] The view password provided by AV clients for authentication"]
#[doc = ""]
#[doc = " \\return true if authentication passes and false if fails."]
#[doc = ""]
pub type authFn = ::std::option::Option<
    unsafe extern "C" fn(
        szViewAccount: *mut ::std::os::raw::c_char,
        szViewPassword: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " \\brief Get the version of AV module"]
    #[doc = ""]
    #[doc = " \\details This function returns the version of AV module."]
    #[doc = ""]
    #[doc = " \\return The version of AV module from high byte to low byte, for example,"]
    #[doc = "\t\t\t0x01020304 means the version is 1.2.3.4"]
    #[doc = ""]
    #[doc = " \\see IOTC_Get_Version(), RDT_GetRDTApiVer()"]
    pub fn avGetAVApiVer() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Reset the Video or Audio buffer of AV server"]
    #[doc = ""]
    #[doc = " \\details This function returns AV_ER_NoERROR if no error"]
    #[doc = ""]
    #[doc = " \\param avIndex [in] The target avIndex"]
    #[doc = " \\param eTarget [in] Reset type could be RESET_VDEIO, RESET_AUDIO, RESET_ALL"]
    #[doc = " \\param Timeout_ms [in] The timeout value in ms to execute this function, set value 0 to wait forever"]
    #[doc = ""]
    #[doc = " \\return This function returns AV_ER_NoERROR if no error"]
    #[doc = ""]
    pub fn avServResetBuffer(
        avIndex: ::std::os::raw::c_int,
        eTarget: AV_RESET_TARGET,
        Timeout_ms: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize AV module"]
    #[doc = ""]
    #[doc = " \\details This function is used by AV servers or AV clients to initialize AV"]
    #[doc = "\t\t\tmodule and shall be called before any AV module related function"]
    #[doc = "\t\t\tis invoked."]
    #[doc = ""]
    #[doc = " \\param nMaxChannelNum [in] The max number of AV channels. If it is"]
    #[doc = "\t\t\tspecified less than 1, AV will set max number of AV channels as 1."]
    #[doc = ""]
    #[doc = " \\return The actual maximum number of AV channels to be set."]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    pub fn avInitialize(nMaxChannelNum: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deinitialize AV module"]
    #[doc = ""]
    #[doc = " \\details This function will deinitialize AV module."]
    #[doc = ""]
    #[doc = " \\return #AV_ER_NoERROR if deinitialize successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_NOT_INITIALIZED the AV module is not initialized yet"]
    #[doc = ""]
    #[doc = " \\attention AV module shall be deinitialized before IOTC module is"]
    #[doc = "\t\t\t\tdeinitialized."]
    pub fn avDeInitialize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Start an AV server"]
    #[doc = ""]
    #[doc = " \\details Start an AV server with predefined view account and password."]
    #[doc = "\t\t\tAny AV client wanting to connect with this AV server shall"]
    #[doc = "\t\t\tprovide matched view account and password."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to start AV server"]
    #[doc = " \\param cszViewAccount [in] The predefined view account"]
    #[doc = " \\param cszViewPassword [in] The predefined view password"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of second"]
    #[doc = "\t\t\t\t\t\tSpecify it as 0 will make AV server start process return"]
    #[doc = "\t\t\t\t\t\tuntil an AV client connects successfully."]
    #[doc = " \\param nServType [in] The user-defined service type. An AV client will get"]
    #[doc = "\t\t\t\t\t\tthis value when it invokes avClientStart() successfully."]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the channel to start AV server"]
    #[doc = ""]
    #[doc = " \\return AV channel ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The IOTC session ID is incorrect or reuse of IOTC session ID"]
    #[doc = "and IOTC channel ID."]
    #[doc = "\t\t\t- #AV_ER_NOT_INITIALIZED AV module is not initialized yet"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_CHANNEL The number of AV channels has reached maximum"]
    #[doc = "\t\t\t- #AV_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session ID is not valid"]
    #[doc = "\t\t\t- #AV_ER_SERVER_EXIT Users stop this function with avServExit() in another thread"]
    #[doc = "\t\t\t- #AV_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\tAV start is performed completely"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avServStart2(), avServExit(), avServStop()"]
    #[doc = ""]
    #[doc = " \\attention (1) This function is a block process.<br><br>"]
    #[doc = "\t\t\t\t(2) The IOTC channel of\tspecified channel ID will be turned on automatically"]
    #[doc = "\t\t\t\tby avServStart()"]
    #[doc = ""]
    pub fn avServStart(
        nIOTCSessionID: ::std::os::raw::c_int,
        cszViewAccount: *const ::std::os::raw::c_char,
        cszViewPassword: *const ::std::os::raw::c_char,
        nTimeout: ::std::os::raw::c_uint,
        nServType: ::std::os::raw::c_uint,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Start an AV server"]
    #[doc = ""]
    #[doc = " \\details Start an AV server with user defined authentication function."]
    #[doc = "\t\t\tAny AV client wanting to connect with this AV server shall"]
    #[doc = "\t\t\tpass the authentication with view account and password."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to create AV server"]
    #[doc = " \\param pfxAuthFn [in] The function pointer to an authentication function"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of second."]
    #[doc = "\t\t\t\t\t\tSpecify it as 0 will make AV server start process return"]
    #[doc = "\t\t\t\t\t\tuntil an AV client connects successfully."]
    #[doc = " \\param nServType [in] The user-defined service type. An AV client will get"]
    #[doc = "\t\t\t\t\t\tthis value when it invokes avClientStart() successfully."]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the channel to create AV server"]
    #[doc = ""]
    #[doc = " \\return AV channel ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The IOTC session ID is incorrect or reuse of IOTC session ID"]
    #[doc = "and IOTC channel ID."]
    #[doc = "\t\t\t- #AV_ER_NOT_INITIALIZED AV module is not initialized yet"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_CHANNEL The number of AV channels has reached maximum"]
    #[doc = "\t\t\t- #AV_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session ID is not valid"]
    #[doc = "\t\t\t- #AV_ER_SERVER_EXIT Users stop this function with avServExit() in another thread"]
    #[doc = "\t\t\t- #AV_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\tAV start is performed completely"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avServStart(), avServExit(), avServStop()"]
    #[doc = ""]
    #[doc = " \\attention (1) This function is a block process.<br><br>"]
    #[doc = "\t\t\t  (2) The IOTC channel of\tspecified channel ID will be turned on automatically"]
    #[doc = "\t\t\t\tby avServStart2()"]
    #[doc = ""]
    pub fn avServStart2(
        nIOTCSessionID: ::std::os::raw::c_int,
        pfxAuthFn: authFn,
        nTimeout: ::std::os::raw::c_uint,
        nServType: ::std::os::raw::c_uint,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Start an AV server"]
    #[doc = ""]
    #[doc = " \\details Start an AV re-send supported server with user defined authentication function."]
    #[doc = "\t\t\tAny AV client wanting to connect with this AV server shall"]
    #[doc = "\t\t\tpass the authentication with view account and password. Whether the re-send mechanism"]
    #[doc = "          is enabled or not depends on AV client settings and will set the result into"]
    #[doc = "          pnResend parameter."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to create AV server"]
    #[doc = " \\param pfxAuthFn [in] The function pointer to an authentication function"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of second."]
    #[doc = "\t\t\t\t\t\tSpecify it as 0 will make AV server start process return"]
    #[doc = "\t\t\t\t\t\tuntil an AV client connects successfully."]
    #[doc = " \\param nServType [in] The user-defined service type. An AV client will get"]
    #[doc = "                       this value when it invokes avClientStart() successfully."]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the channel to create AV server"]
    #[doc = ""]
    #[doc = " \\param pnResend [out] Set the re-send is enabled or not."]
    #[doc = ""]
    #[doc = " \\return AV channel ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The IOTC session ID is incorrect or reuse of IOTC session ID"]
    #[doc = "               and IOTC channel ID."]
    #[doc = "\t\t\t- #AV_ER_NOT_INITIALIZED AV module is not initialized yet"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_CHANNEL The number of AV channels has reached maximum"]
    #[doc = "\t\t\t- #AV_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session ID is not valid"]
    #[doc = "\t\t\t- #AV_ER_SERVER_EXIT Users stop this function with avServExit() in another thread"]
    #[doc = "\t\t\t- #AV_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\tAV start is performed completely"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avServStart(), avServStart2(), avServExit(), avServStop()"]
    #[doc = ""]
    #[doc = " \\attention (1) This function is a block process.<br><br>"]
    #[doc = "\t\t\t  (2) The IOTC channel of specified channel ID will be turned on automatically"]
    #[doc = "\t\t\t \t   by avServStart3()"]
    #[doc = ""]
    pub fn avServStart3(
        nIOTCSessionID: ::std::os::raw::c_int,
        pfxAuthFn: authFn,
        nTimeout: ::std::os::raw::c_uint,
        nServType: ::std::os::raw::c_uint,
        nIOTCChannelID: ::std::os::raw::c_uchar,
        pnResend: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by an AV server exit avServStart() or avServStart2() process"]
    #[doc = ""]
    #[doc = " \\details Since avServStart() and avServStart2() are block processes and"]
    #[doc = "\t\t\tthat means the caller has to wait for AV start or specified timeout"]
    #[doc = "\t\t\texpires\tbefore these two functions return. In some cases,"]
    #[doc = "\t\t\tcaller may want\tto exit AV start process immediately by this"]
    #[doc = "\t\t\tfunction in another thread."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to exit AV start process"]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the channel to exit AV start process"]
    #[doc = ""]
    pub fn avServExit(
        nIOTCSessionID: ::std::os::raw::c_int,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief Stop an AV server"]
    #[doc = ""]
    #[doc = " \\details An AV server stop AV channel by this function if this channel is"]
    #[doc = "\t\t\tno longer required."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be stopped"]
    #[doc = ""]
    pub fn avServStop(nAVChannelID: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Set re-send buffer size."]
    #[doc = ""]
    #[doc = " \\details Use this API to set the re-send buffer size if re-send mechanism is enabled."]
    #[doc = "          Default re-send buffer size is 256KB and recommend size is 1 second data."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be set."]
    #[doc = " \\param nSize [in] The size of re-send buffer, in unit of kilo-byte."]
    #[doc = ""]
    pub fn avServSetResendSize(nAVChannelID: ::std::os::raw::c_int, nSize: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " \\brief An AV server sends frame data to an AV client"]
    #[doc = ""]
    #[doc = " \\details An AV server uses this function to send frame data to AV client"]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be sent"]
    #[doc = " \\param cabFrameData [in] The frame data to be sent"]
    #[doc = " \\param nFrameDataSize [in] The size of the frame data"]
    #[doc = " \\param cabFrameInfo [in] The video frame information to be sent"]
    #[doc = " \\param nFrameInfoSize [in] The size of the video frame information"]
    #[doc = ""]
    #[doc = " \\return #AV_ER_NoERROR if sending successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    #[doc = "\t\t\t- #AV_ER_CLIENT_NOT_SUPPORT An AV client uses this function to send frame data"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session of this AV channel is not valid"]
    #[doc = "\t\t\t- #AV_ER_CLIENT_NO_AVLOGIN An AV client does not pass authentication yet"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_SIZE The frame data and frame info to be sent exceeds"]
    #[doc = "\t\t\t\tcurrently remaining video frame buffer. The max size of video frame"]
    #[doc = "\t\t\t\tbuffer is determined by avServSetMaxBufSize()"]
    #[doc = "\t\t\t- #AV_ER_MEM_INSUFF Insufficient memory for allocation"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avSendAudioData()"]
    #[doc = ""]
    pub fn avSendFrameData(
        nAVChannelID: ::std::os::raw::c_int,
        cabFrameData: *const ::std::os::raw::c_char,
        nFrameDataSize: ::std::os::raw::c_int,
        cabFrameInfo: *const ::std::os::raw::c_void,
        nFrameInfoSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief An AV server sends audio data to an AV client"]
    #[doc = ""]
    #[doc = " \\details An AV server uses this function to send audio data to AV client"]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be sent"]
    #[doc = " \\param cabAudioData [in] The audio data to be sent"]
    #[doc = " \\param nAudioDataSize [in] The size of the audio data"]
    #[doc = " \\param cabFrameInfo [in] The audio frame information to be sent"]
    #[doc = " \\param nFrameInfoSize [in] The size of the audio frame information"]
    #[doc = ""]
    #[doc = " \\return #AV_ER_NoERROR if sending successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    #[doc = "\t\t\t- #AV_ER_CLIENT_NOT_SUPPORT An AV client uses this function to send frame data"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session of this AV channel is not valid"]
    #[doc = "\t\t\t- #AV_ER_CLIENT_NO_AVLOGIN An AV client does not pass authentication yet"]
    #[doc = "\t\t\t- #AV_ER_MEM_INSUFF Insufficient memory for allocation"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_SIZE The audio data and frame info to be sent exceeds"]
    #[doc = "\t\t\t\t#AV_MAX_AUDIO_DATA_SIZE"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avSendFrameData()"]
    #[doc = ""]
    pub fn avSendAudioData(
        nAVChannelID: ::std::os::raw::c_int,
        cabAudioData: *const ::std::os::raw::c_char,
        nAudioDataSize: ::std::os::raw::c_int,
        cabFrameInfo: *const ::std::os::raw::c_void,
        nFrameInfoSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set interval of sending video data in AV server"]
    #[doc = ""]
    #[doc = " \\details An AV server how to send video data to AV client."]
    #[doc = "\t\t\tIt determined the delay time at regular interval between how many packets."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be sent"]
    #[doc = " \\param nPacketNum [in] How many number of packet as a regular interval"]
    #[doc = " \\param nDelayMs [in] Delay time in unit of million-second"]
    #[doc = ""]
    #[doc = " \\return #AV_ER_NoERROR if set successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid"]
    #[doc = ""]
    #[doc = ""]
    pub fn avServSetDelayInterval(
        nAVChannelID: ::std::os::raw::c_int,
        nPacketNum: ::std::os::raw::c_ushort,
        nDelayMs: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Start an AV client"]
    #[doc = ""]
    #[doc = " \\details Start an AV client by providing view account and password."]
    #[doc = "\t\t\tIt shall pass the authentication of the AV server before receiving"]
    #[doc = "\t\t\tAV data."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to start AV client"]
    #[doc = " \\param cszViewAccount [in] The view account for authentication"]
    #[doc = " \\param cszViewPassword [in] The view password for authentication"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of second"]
    #[doc = "\t\t\t\t\t\tSpecify it as 0 will make this AV client try connection"]
    #[doc = "\t\t\t\t\t\tonce and this process will exit immediately if not"]
    #[doc = "\t\t\t\t\t\tconnection is unsuccessful."]
    #[doc = " \\param pnServType [out] The user-defined service type set when an AV server"]
    #[doc = "\t\t\t\t\t\tstarts. Can be NULL."]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the channel to start AV client"]
    #[doc = ""]
    #[doc = " \\return AV channel ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The IOTC session ID is incorrect or reuse of IOTC session ID"]
    #[doc = "              and IOTC channel ID."]
    #[doc = "\t\t\t- #AV_ER_NOT_INITIALIZED AV module is not initialized yet"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_CHANNEL The number of AV channels has reached maximum"]
    #[doc = "\t\t\t- #AV_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #AV_ER_SERV_NO_RESPONSE The AV server has no response"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session ID is not valid"]
    #[doc = "\t\t\t- #AV_ER_CLIENT_EXIT Users stop this function with avClientExit() in another thread"]
    #[doc = "\t\t\t- #AV_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\tAV start is performed completely"]
    #[doc = "\t\t\t- #AV_ER_WRONG_VIEWACCorPWD The client fails in authentication due"]
    #[doc = "\t\t\t\tto incorrect view account or password"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avClientStop(), avClientExit()"]
    #[doc = ""]
    #[doc = " \\attention (1) This function is a block process.<br><br>"]
    #[doc = "\t\t\t\t (2) The IOTC channel of specified channel ID will be turned on automatically"]
    #[doc = "\t\t\t\tby avClientStart()."]
    #[doc = ""]
    pub fn avClientStart(
        nIOTCSessionID: ::std::os::raw::c_int,
        cszViewAccount: *const ::std::os::raw::c_char,
        cszViewPassword: *const ::std::os::raw::c_char,
        nTimeout: ::std::os::raw::c_uint,
        pnServType: *mut ::std::os::raw::c_uint,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Start an AV client"]
    #[doc = ""]
    #[doc = " \\details Start an AV re-send supported client by providing view account and password."]
    #[doc = "\t\t\tIt shall pass the authentication of the AV server before receiving"]
    #[doc = "\t\t\tAV data. Whether the re-send mechanism is enabled or not depends on AV server settings"]
    #[doc = "          and will set the result into pnResend parameter."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to start AV client"]
    #[doc = " \\param cszViewAccount [in] The view account for authentication"]
    #[doc = " \\param cszViewPassword [in] The view password for authentication"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of second"]
    #[doc = "\t\t\t\t\t\tSpecify it as 0 will make this AV client try connection"]
    #[doc = "\t\t\t\t\t\tonce and this process will exit immediately if not"]
    #[doc = "\t\t\t\t\t\tconnection is unsuccessful."]
    #[doc = " \\param pnServType [out] The user-defined service type set when an AV server"]
    #[doc = "\t\t\t\t\t\tstarts. Can be NULL."]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the channel to start AV client"]
    #[doc = " \\param pnResend [out] Set the re-send is enabled or not."]
    #[doc = ""]
    #[doc = " \\return AV channel ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The IOTC session ID is incorrect or reuse of IOTC session ID"]
    #[doc = "and IOTC channel ID."]
    #[doc = "\t\t\t- #AV_ER_NOT_INITIALIZED AV module is not initialized yet"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_CHANNEL The number of AV channels has reached maximum"]
    #[doc = "\t\t\t- #AV_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #AV_ER_SERV_NO_RESPONSE The AV server has no response"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session ID is not valid"]
    #[doc = "\t\t\t- #AV_ER_CLIENT_EXIT Users stop this function with avClientExit() in another thread"]
    #[doc = "\t\t\t- #AV_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\tAV start is performed completely"]
    #[doc = "\t\t\t- #AV_ER_WRONG_VIEWACCorPWD The client fails in authentication due"]
    #[doc = "\t\t\t\tto incorrect view account or password"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avClientStop(), avClientExit()"]
    #[doc = ""]
    #[doc = " \\attention (1) This function is a block process.<br><br>"]
    #[doc = "\t\t\t  (2) The IOTC channel of specified channel ID will be turned on automatically"]
    #[doc = "\t\t\t\t  by avClientStart2().<br><br>"]
    #[doc = "            (3) If AV client uses avClientStart2() to enable AV re-send mechanism, it has"]
    #[doc = "                to use avRecvFrameData2() to receive video data."]
    #[doc = ""]
    pub fn avClientStart2(
        nIOTCSessionID: ::std::os::raw::c_int,
        cszViewAccount: *const ::std::os::raw::c_char,
        cszViewPassword: *const ::std::os::raw::c_char,
        nTimeout: ::std::os::raw::c_uint,
        pnServType: *mut ::std::os::raw::c_uint,
        nIOTCChannelID: ::std::os::raw::c_uchar,
        pnResend: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by an AV client exit avClientStart() process"]
    #[doc = ""]
    #[doc = " \\details Since avClientStart() is a block process and"]
    #[doc = "\t\t\tthat means the caller has to wait for AV start or specified timeout"]
    #[doc = "\t\t\texpires\tbefore these two functions return. In some cases,"]
    #[doc = "\t\t\tcaller may want\tto exit AV start process immediately by this"]
    #[doc = "\t\t\tfunction in another thread."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to exit AV start process"]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the channel to exit AV start process"]
    #[doc = ""]
    pub fn avClientExit(
        nIOTCSessionID: ::std::os::raw::c_int,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " \\brief Stop an AV client"]
    #[doc = ""]
    #[doc = " \\details An AV client stop AV channel by this function if this channel is"]
    #[doc = "\t\t\tno longer required."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be stopped"]
    #[doc = ""]
    pub fn avClientStop(nAVChannelID: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief An AV client receives frame data from an AV server"]
    #[doc = ""]
    #[doc = " \\details An AV client uses this function to receive frame data from AV server"]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be received"]
    #[doc = " \\param abFrameData [out] The frame data to be received"]
    #[doc = " \\param nFrameDataMaxSize [in] The max size of the frame data"]
    #[doc = " \\param abFrameInfo [out] The video frame information to be received"]
    #[doc = " \\param nFrameInfoMaxSize [in] The max size of the video frame information"]
    #[doc = " \\param pnFrameIdx [out] The index of current receiving video frame"]
    #[doc = ""]
    #[doc = " \\return The actual length of received result stored in abFrameData if successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session of this AV channel is not valid"]
    #[doc = "\t\t\t- #AV_ER_DATA_NOREADY The data is not ready for receiving yet."]
    #[doc = "\t\t\t- #AV_ER_LOSED_THIS_FRAME The whole frame is lost during receiving"]
    #[doc = "\t\t\t- #AV_ER_BUFPARA_MAXSIZE_INSUFF The frame to be received exceeds"]
    #[doc = "\t\t\t\tthe size of abFrameData, i.e. nFrameDataMaxSize"]
    #[doc = "\t\t\t- #AV_ER_MEM_INSUFF Insufficient memory for allocation"]
    #[doc = "\t\t\t- #AV_ER_INCOMPLETE_FRAME Some parts of a frame are lost during receiving"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avRecvAudioData()"]
    #[doc = ""]
    pub fn avRecvFrameData(
        nAVChannelID: ::std::os::raw::c_int,
        abFrameData: *mut ::std::os::raw::c_char,
        nFrameDataMaxSize: ::std::os::raw::c_int,
        abFrameInfo: *mut ::std::os::raw::c_char,
        nFrameInfoMaxSize: ::std::os::raw::c_int,
        pnFrameIdx: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief A new version AV client receives frame data from an AV server"]
    #[doc = ""]
    #[doc = " \\details An AV client uses this function to receive frame data from AV server"]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be received"]
    #[doc = " \\param abFrameData [out] The frame data to be received"]
    #[doc = " \\param nFrameDataMaxSize [in] The max size of the frame data"]
    #[doc = " \\param pnActualFrameSize [in] The actual size of frame data to be received, maybe less than expected size"]
    #[doc = " \\param pnExpectedFrameSize [in] The size of frame data expect to be received that sent from av server"]
    #[doc = " \\param abFrameInfo [out] The video frame information to be received"]
    #[doc = " \\param nFrameInfoMaxSize [in] The max size of the video frame information"]
    #[doc = " \\param pnActualFrameInfoSize [in] The actual size of the video frame information to be received"]
    #[doc = " \\param pnFrameIdx [out] The index of current receiving video frame"]
    #[doc = ""]
    #[doc = " \\return The actual length of received result stored in abFrameData if successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session of this AV channel is not valid"]
    #[doc = "\t\t\t- #AV_ER_DATA_NOREADY The data is not ready for receiving yet."]
    #[doc = "\t\t\t- #AV_ER_LOSED_THIS_FRAME The whole frame is lost during receiving"]
    #[doc = "\t\t\t- #AV_ER_BUFPARA_MAXSIZE_INSUFF The frame to be received exceeds"]
    #[doc = "\t\t\t\tthe size of abFrameData, i.e. nFrameDataMaxSize"]
    #[doc = "\t\t\t- #AV_ER_MEM_INSUFF Insufficient memory for allocation"]
    #[doc = "\t\t\t- #AV_ER_INCOMPLETE_FRAME Some parts of a frame are lost during receiving"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avRecvAudioData()"]
    #[doc = ""]
    pub fn avRecvFrameData2(
        nAVChannelID: ::std::os::raw::c_int,
        abFrameData: *mut ::std::os::raw::c_char,
        nFrameDataMaxSize: ::std::os::raw::c_int,
        pnActualFrameSize: *mut ::std::os::raw::c_int,
        pnExpectedFrameSize: *mut ::std::os::raw::c_int,
        abFrameInfo: *mut ::std::os::raw::c_char,
        nFrameInfoMaxSize: ::std::os::raw::c_int,
        pnActualFrameInfoSize: *mut ::std::os::raw::c_int,
        pnFrameIdx: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief An AV client receives audio data from an AV server"]
    #[doc = ""]
    #[doc = " \\details An AV client uses this function to receive audio data from AV server"]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to be received"]
    #[doc = " \\param abAudioData [out] The audio data to be received"]
    #[doc = " \\param nAudioDataMaxSize [in] The max size of the audio data"]
    #[doc = " \\param abFrameInfo [out] The audio frame information to be received"]
    #[doc = " \\param nFrameInfoMaxSize [in] The max size of the audio frame information"]
    #[doc = " \\param pnFrameIdx [out] The index of current receiving audio frame"]
    #[doc = ""]
    #[doc = " \\return The actual length of received result stored in abAudioData if successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session of this AV channel is not valid"]
    #[doc = "\t\t\t- #AV_ER_DATA_NOREADY The data is not ready for receiving yet."]
    #[doc = "\t\t\t- #AV_ER_LOSED_THIS_FRAME The whole frame is lost during receiving"]
    #[doc = "\t\t\t- #AV_ER_BUFPARA_MAXSIZE_INSUFF The data and frame info to be received"]
    #[doc = "\t\t\t\texceeds\tthe size of abAudioData and abFrameInfo, respectively."]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avRecvFrameData()"]
    #[doc = ""]
    pub fn avRecvAudioData(
        nAVChannelID: ::std::os::raw::c_int,
        abAudioData: *mut ::std::os::raw::c_char,
        nAudioDataMaxSize: ::std::os::raw::c_int,
        abFrameInfo: *mut ::std::os::raw::c_char,
        nFrameInfoMaxSize: ::std::os::raw::c_int,
        pnFrameIdx: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Get the frame count of audio buffer remaining in the queue"]
    #[doc = ""]
    #[doc = " \\details An AV client uses this function to get the frame count of audio buffer"]
    #[doc = "\t\t\tthat is still remaining in the receiving queue, then determine"]
    #[doc = "\t\t\twhether it is a right time to invoke avRecvAudioData()."]
    #[doc = "\t\t\tKeeping audio buffer in audio queue instead of receiving immediately"]
    #[doc = "\t\t\tcan greatly improve the discontinuous audio issues. However,"]
    #[doc = "\t\t\tit is not good to receive audio in a very long time since audio"]
    #[doc = "\t\t\tbuffer will overflow and audio data will be lost."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to check audio buffer"]
    #[doc = ""]
    #[doc = " \\return The frame count of audio buffer"]
    pub fn avCheckAudioBuf(nAVChannelID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set the maximum video frame buffer used in AV client"]
    #[doc = ""]
    #[doc = " \\details AV client sets the maximum video frame buffer by this function."]
    #[doc = "\t\t\tThe size of video frame buffer will affect the streaming fluency."]
    #[doc = "\t\t\tThe default size of video frame buffer is 1MB."]
    #[doc = ""]
    #[doc = " \\param nMaxBufSize The maximum video frame buffer, in unit of kilo-byte"]
    #[doc = ""]
    pub fn avClientSetMaxBufSize(nMaxBufSize: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " \\brief Clean the video and audio buffer"]
    #[doc = ""]
    #[doc = " \\details A client with multiple device connection application should call"]
    #[doc = "\t\t\tthis function to clean AV buffer while switch to another devices."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to clean buffer"]
    #[doc = ""]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    pub fn avClientCleanBuf(nAVChannelID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Clean the video buffer"]
    #[doc = ""]
    #[doc = " \\details A client with multiple device connection application should call"]
    #[doc = "\t\t\tthis function to clean video buffer while switch to another devices."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to clean buffer"]
    #[doc = ""]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    pub fn avClientCleanVideoBuf(nAVChannelID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Clean the aduio buffer"]
    #[doc = ""]
    #[doc = " \\details A client with multiple device connection application should call"]
    #[doc = "\t\t\tthis function to clean audio buffer while switch listen to speaker."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the audio channel to clean buffer"]
    #[doc = ""]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or frame data is null"]
    pub fn avClientCleanAudioBuf(nAVChannelID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Send AV IO control"]
    #[doc = ""]
    #[doc = " \\details This function is used by AV servers or AV clients to send a"]
    #[doc = "\t\t\tAV IO control."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to send IO control"]
    #[doc = " \\param nIOCtrlType [in] The type of IO control"]
    #[doc = " \\param cabIOCtrlData [in] The buffer of IO control data"]
    #[doc = " \\param nIOCtrlDataSize [in] The length of IO control data"]
    #[doc = ""]
    #[doc = " \\return #AV_ER_NoERROR if sending successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid"]
    #[doc = "\t\t\t- #AV_ER_SENDIOCTRL_ALREADY_CALLED This AV channel is already in sending"]
    #[doc = "\t\t\t\tIO control process"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session of this AV channel is not valid"]
    #[doc = "\t\t\t- #AV_ER_SENDIOCTRL_EXIT avSendIOCtrlExit() is called before this"]
    #[doc = "\t\t\t\tfunction is returned"]
    #[doc = "\t\t\t- #AV_ER_EXCEED_MAX_SIZE The IO control data and type to be sent exceeds"]
    #[doc = "\t\t\t\t#AV_MAX_IOCTRL_DATA_SIZE"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avRecvIOCtrl(), avSendIOCtrlExit()"]
    #[doc = ""]
    #[doc = " \\attention This function is a block process and it will return until"]
    #[doc = "\t\t\t\thaving acknowledgment from the receiver."]
    pub fn avSendIOCtrl(
        nAVChannelID: ::std::os::raw::c_int,
        nIOCtrlType: ::std::os::raw::c_uint,
        cabIOCtrlData: *const ::std::os::raw::c_char,
        nIOCtrlDataSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Receive AV IO control"]
    #[doc = ""]
    #[doc = " \\details This function is used by AV servers or AV clients to receive a"]
    #[doc = "\t\t\tAV IO control."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel to receive IO control"]
    #[doc = " \\param pnIOCtrlType [out] The type of received IO control"]
    #[doc = " \\param abIOCtrlData [out] The buffer of received IO control data"]
    #[doc = " \\param nIOCtrlMaxDataSize [in] The max length of buffer of received IO control data"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of million-second, give 0 means return immediately"]
    #[doc = ""]
    #[doc = " \\return The actual length of received result stored in abIOCtrlData if"]
    #[doc = "\t\t\treceiving IO control successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid or IO control type"]
    #[doc = "\t\t\t\t/ data is null"]
    #[doc = "\t\t\t- #AV_ER_SESSION_CLOSE_BY_REMOTE The remote site already closes"]
    #[doc = "\t\t\t\tthis IOTC session"]
    #[doc = "\t\t\t- #AV_ER_REMOTE_TIMEOUT_DISCONNECT The timeout expires because"]
    #[doc = "\t\t\t\tremote site has no response."]
    #[doc = "\t\t\t- #AV_ER_INVALID_SID The IOTC session of this AV channel is not valid"]
    #[doc = "\t\t\t- #AV_ER_DATA_NOREADY The IO control is not ready for receiving yet."]
    #[doc = "\t\t\t- #AV_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\treceiving IO control process is performed completely"]
    #[doc = "\t\t\t- #AV_ER_BUFPARA_MAXSIZE_INSUFF The IO control data to be received exceeds"]
    #[doc = "\t\t\t\tthe size of abIOCtrlData, i.e. nIOCtrlMaxDataSize"]
    #[doc = "\t\t\t- #AV_ER_NO_PERMISSION the AV module does not support Lite UID"]
    #[doc = ""]
    #[doc = " \\see avSendIOCtrl()"]
    #[doc = ""]
    pub fn avRecvIOCtrl(
        nAVChannelID: ::std::os::raw::c_int,
        pnIOCtrlType: *mut ::std::os::raw::c_uint,
        abIOCtrlData: *mut ::std::os::raw::c_char,
        nIOCtrlMaxDataSize: ::std::os::raw::c_int,
        nTimeout: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by an AV server or an AV client to exit sending IO control process"]
    #[doc = ""]
    #[doc = " \\details Since avSendIOCtrl() process is a block process and that means"]
    #[doc = "\t\t\tthe caller has to wait for the acknowledgment from the receipt"]
    #[doc = "\t\t\tbefore avSendIOCtrl() returns. In some cases, caller may want"]
    #[doc = "\t\t\tto exit sending immediately by this function in another thread."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel in sending IO control"]
    #[doc = ""]
    #[doc = " \\return #AV_ER_NoERROR if sending successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #AV_ER_INVALID_ARG The AV channel ID is not valid"]
    pub fn avSendIOCtrlExit(nAVChannelID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by an AV server, in order to know the usage rate of resend buffer"]
    #[doc = ""]
    #[doc = " \\details AV server calls this function to know the usage rate of resend buffer."]
    #[doc = "          It will return a float value between 0 and 1."]
    #[doc = "          0 means that resend buffer is empty, 1 means that resend buffer is full."]
    #[doc = "          The others mean usage rate."]
    #[doc = ""]
    #[doc = " \\param nAVChannelID [in] The channel ID of the AV channel"]
    #[doc = ""]
    #[doc = " \\return Usage rate of resend buffer, if return value >= 0."]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "          - #AV_ER_INVALID_ARG The AV channel ID is not valid"]
    pub fn avResendBufUsageRate(nAVChannelID: ::std::os::raw::c_int) -> f32;
}
#[doc = " IOTC session will be established in non-secure mode. <br>"]
#[doc = " - For devices, the behavior is the same as IOTC_Listen(). <br>"]
#[doc = " - For clients, the behavior is the same as IOTC_Connect_ByUID()"]
pub const IOTCSessionMode_IOTC_NON_SECURE_MODE: IOTCSessionMode = 0;
#[doc = " IOTC session will be established in secure mode. <br>"]
#[doc = " - For devices, it means only secure connection will be accepted. <br>"]
#[doc = " - For clients, it means only secure connection will be performed"]
pub const IOTCSessionMode_IOTC_SECURE_MODE: IOTCSessionMode = 1;
#[doc = " IOTC session will be established in either non-secure or secure mode,"]
#[doc = " depending on remote site's request. Can use IOTC_Session_Check()"]
#[doc = " to check what mode is actually used. <br>"]
#[doc = " - For devices, it means both non-secure or secure modes are accepted. <br>"]
#[doc = " - For clients, it means either non-secure or secure modes can be performed."]
pub const IOTCSessionMode_IOTC_ARBITRARY_MODE: IOTCSessionMode = 2;
#[doc = " \\details IOTC session mode, used in IOTC_Listen2(), IOTC_Connect_ByUID2()"]
#[doc = "\t\t\tto specify what kinds of IOTC session"]
#[doc = "\t\t\tthat devices will listen or clients will connect."]
pub type IOTCSessionMode = ::std::os::raw::c_uint;
#[doc = " \\details IOTC session info, containing all the information when a IOTC session is"]
#[doc = "  established between a device and a client. Users can use IOTC_Session_Check()"]
#[doc = "  to get IOTC session information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_SInfo {
    #[doc = "!< 0: P2P mode, 1: Relay mode, 2: LAN mode"]
    pub Mode: ::std::os::raw::c_uchar,
    #[doc = "!< 0: As a Client, 1: As a Device"]
    pub CorD: ::std::os::raw::c_char,
    #[doc = "!< The UID of the device"]
    pub UID: [::std::os::raw::c_char; 21usize],
    #[doc = "!< The IP address of remote site used during this IOTC session"]
    pub RemoteIP: [::std::os::raw::c_char; 17usize],
    #[doc = "!< The port number of remote site used during this IOTC session"]
    pub RemotePort: ::std::os::raw::c_ushort,
    #[doc = "!< The total packets sent from the device and the client during this IOTC session"]
    pub TX_Packetcount: ::std::os::raw::c_uint,
    #[doc = "!< The total packets received in the device and the client during this IOTC session"]
    pub RX_Packetcount: ::std::os::raw::c_uint,
    #[doc = "!< The IOTC version"]
    pub IOTCVersion: ::std::os::raw::c_uint,
    #[doc = "!< The Vendor ID, part of VPG mechanism"]
    pub VID: ::std::os::raw::c_ushort,
    #[doc = "!< The Product ID, part of VPG mechanism"]
    pub PID: ::std::os::raw::c_ushort,
    #[doc = "!< The Group ID, part of VPG mechanism"]
    pub GID: ::std::os::raw::c_ushort,
    #[doc = "!< The remote NAT type"]
    pub NatType: ::std::os::raw::c_uchar,
    #[doc = "!< 0: The IOTC session is in non-secure mode, 1: The IOTC session is in secure mode"]
    pub isSecure: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_st_SInfo() {
    assert_eq!(
        ::std::mem::size_of::<st_SInfo>(),
        64usize,
        concat!("Size of: ", stringify!(st_SInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<st_SInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(st_SInfo))
    );
    fn test_field_Mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(Mode)
            )
        );
    }
    test_field_Mode();
    fn test_field_CorD() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CorD) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(CorD)
            )
        );
    }
    test_field_CorD();
    fn test_field_UID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(UID)
            )
        );
    }
    test_field_UID();
    fn test_field_RemoteIP() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RemoteIP) as usize - ptr as usize
            },
            23usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(RemoteIP)
            )
        );
    }
    test_field_RemoteIP();
    fn test_field_RemotePort() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RemotePort) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(RemotePort)
            )
        );
    }
    test_field_RemotePort();
    fn test_field_TX_Packetcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).TX_Packetcount) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(TX_Packetcount)
            )
        );
    }
    test_field_TX_Packetcount();
    fn test_field_RX_Packetcount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RX_Packetcount) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(RX_Packetcount)
            )
        );
    }
    test_field_RX_Packetcount();
    fn test_field_IOTCVersion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IOTCVersion) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(IOTCVersion)
            )
        );
    }
    test_field_IOTCVersion();
    fn test_field_VID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VID) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(VID)
            )
        );
    }
    test_field_VID();
    fn test_field_PID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).PID) as usize - ptr as usize
            },
            58usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(PID)
            )
        );
    }
    test_field_PID();
    fn test_field_GID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GID) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(GID)
            )
        );
    }
    test_field_GID();
    fn test_field_NatType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NatType) as usize - ptr as usize
            },
            62usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(NatType)
            )
        );
    }
    test_field_NatType();
    fn test_field_isSecure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_SInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isSecure) as usize - ptr as usize
            },
            63usize,
            concat!(
                "Offset of field: ",
                stringify!(st_SInfo),
                "::",
                stringify!(isSecure)
            )
        );
    }
    test_field_isSecure();
}
#[doc = " \\details Device serch info, containing all the information"]
#[doc = " when client searches devices in LAN."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_LanSearchInfo {
    #[doc = "!< The UID of discoveried device"]
    pub UID: [::std::os::raw::c_char; 21usize],
    #[doc = "!< The IP address of discoveried device"]
    pub IP: [::std::os::raw::c_char; 16usize],
    #[doc = "!< The port number of discoveried device used for IOTC session connection"]
    pub port: ::std::os::raw::c_ushort,
    #[doc = "!< Reserved, no use"]
    pub Reserved: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_st_LanSearchInfo() {
    assert_eq!(
        ::std::mem::size_of::<st_LanSearchInfo>(),
        42usize,
        concat!("Size of: ", stringify!(st_LanSearchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<st_LanSearchInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(st_LanSearchInfo))
    );
    fn test_field_UID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo),
                "::",
                stringify!(UID)
            )
        );
    }
    test_field_UID();
    fn test_field_IP() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IP) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo),
                "::",
                stringify!(IP)
            )
        );
    }
    test_field_IP();
    fn test_field_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize
            },
            38usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo),
                "::",
                stringify!(port)
            )
        );
    }
    test_field_port();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo),
                "::",
                stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
}
#[doc = " \\details Device serch info, containing all the information and device name"]
#[doc = " when client searches devices in LAN."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_LanSearchInfo2 {
    #[doc = "!< The UID of discoveried device"]
    pub UID: [::std::os::raw::c_char; 21usize],
    #[doc = "!< The IP address of discoveried device"]
    pub IP: [::std::os::raw::c_char; 16usize],
    #[doc = "!< The port number of discoveried device used for IOTC session connection"]
    pub port: ::std::os::raw::c_ushort,
    #[doc = "!< The Name of discoveried device"]
    pub DeviceName: [::std::os::raw::c_char; 129usize],
    #[doc = "!< Reserved, no use"]
    pub Reserved: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_st_LanSearchInfo2() {
    assert_eq!(
        ::std::mem::size_of::<st_LanSearchInfo2>(),
        170usize,
        concat!("Size of: ", stringify!(st_LanSearchInfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<st_LanSearchInfo2>(),
        2usize,
        concat!("Alignment of ", stringify!(st_LanSearchInfo2))
    );
    fn test_field_UID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UID) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo2),
                "::",
                stringify!(UID)
            )
        );
    }
    test_field_UID();
    fn test_field_IP() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IP) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo2),
                "::",
                stringify!(IP)
            )
        );
    }
    test_field_IP();
    fn test_field_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize
            },
            38usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo2),
                "::",
                stringify!(port)
            )
        );
    }
    test_field_port();
    fn test_field_DeviceName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DeviceName) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo2),
                "::",
                stringify!(DeviceName)
            )
        );
    }
    test_field_DeviceName();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_LanSearchInfo2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            169usize,
            concat!(
                "Offset of field: ",
                stringify!(st_LanSearchInfo2),
                "::",
                stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
}
#[doc = " \\details The prototype of getting login info function, used by a device"]
#[doc = "\t\t\tto be notified if it is still kept login with IOTC servers or is"]
#[doc = "\t\t\tdisconnected with IOTC servers."]
#[doc = ""]
#[doc = " \\param pnLoginInfo [out] The login info with meanings of following bits"]
#[doc = "\t\t\t- bit 0: the device is ready for connection by client from LAN if this bit is 1"]
#[doc = "\t\t\t- bit 1: the device is ready for connection by client from Internet if this bit is 1"]
#[doc = "\t\t\t- bit 2: if this bit is 1, it means the device has received login"]
#[doc = "\t\t\t\t\t\tresponse from IOTC servers since IOTC_Get_Login_Info()"]
#[doc = "\t\t\t\t\t\tis called last time."]
#[doc = ""]
pub type loginInfoCB =
    ::std::option::Option<unsafe extern "C" fn(nLoginInfo: ::std::os::raw::c_uint)>;
#[doc = " \\details The prototype of getting session status function, used by a device"]
#[doc = "\t\t\tor client to be notified if session is disconnected."]
#[doc = ""]
#[doc = " \\param nIOTCSessionID [out] The session ID of the session being disconnected"]
#[doc = " \\param nErrorCode [out]"]
#[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
#[doc = "\t\t\t\tsession ID has been closed by remote site"]
#[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
#[doc = "\t\t\t\texpires because\tremote site has no response"]
#[doc = ""]
pub type sessionStatusCB = ::std::option::Option<
    unsafe extern "C" fn(nIOTCSessionID: ::std::os::raw::c_int, nErrorCode: ::std::os::raw::c_int),
>;
extern "C" {
    #[doc = " \\brief Get the version of IOTC module"]
    #[doc = ""]
    #[doc = " \\details This function returns the version of IOTC module."]
    #[doc = ""]
    #[doc = " \\param pnVersion [out] The version of IOTC module. It contains"]
    #[doc = "\t\t\tthe version from high byte to low byte, for example, 0x01020304"]
    #[doc = "\t\t\tmeans the version is 1.2.3.4"]
    #[doc = ""]
    #[doc = " \\see RDT_GetRDTApiVer(), avGetAVApiVer()"]
    pub fn IOTC_Get_Version(pnVersion: *mut ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " \\brief Set the max number of IOTC sessions of IOTC module"]
    #[doc = ""]
    #[doc = " \\details This function set the max number of allowable IOTC sessions in IOTC"]
    #[doc = "\t\t\tmodule. The max number of IOTC session limits the max number of"]
    #[doc = "\t\t\tconnected clients in device side, while it limits the max number"]
    #[doc = "\t\t\tconnected devices in client\tside. A device or a client could use"]
    #[doc = "\t\t\tthis function to reduce the number of IOTC sessions in order to save"]
    #[doc = "\t\t\tsome memory usage."]
    #[doc = ""]
    #[doc = " \\param nMaxSessionNum [in] The max number of IOTC sessions"]
    #[doc = ""]
    #[doc = " \\attention\t(1) This function is optional if users do not want to change the"]
    #[doc = "\t\t\t\tdefault max number of IOTC sessions, i.e. MAX_DEFAULT_IOTC_SESSION_NUMBER."]
    #[doc = "\t\t\t\tHowever, if users really wants to change it, this function"]
    #[doc = "\t\t\t\tshall be called before IOTC platform is initialized.<br><br>"]
    #[doc = "\t\t\t\t(2) The maximum IOTC session number is platform dependent."]
    #[doc = "\t\t\t\tSee the definition of MAX_DEFAULT_IOTC_SESSION_NUMBER for each"]
    #[doc = "\t\t\t\tplatform."]
    pub fn IOTC_Set_Max_Session_Number(nMaxSessionNum: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " \\brief Initialize IOTC module"]
    #[doc = ""]
    #[doc = " \\details This function is used by devices or clients to initialize IOTC"]
    #[doc = "\t\t\tmodule and shall be called before any IOTC module related"]
    #[doc = "\t\t\tfunction is invoked except for IOTC_Set_Max_Session_Number()."]
    #[doc = ""]
    #[doc = " \\param nUDPPort [in] Specify a UDP port. Random UDP port is used if it is specified as 0."]
    #[doc = " \\param cszP2PHostNamePrimary [in] Specify the host name or IP address of"]
    #[doc = "\t\t\tthe primary master. Cannot be NULL. See attention below for more detail."]
    #[doc = " \\param cszP2PHostNameSecondary [in] Specify the host name or IP address of"]
    #[doc = "\t\t\tthe secondary master. Cannot be NULL. See attention below for more detail."]
    #[doc = " \\param cszP2PHostNameThird [in] Specify the host name or IP address of"]
    #[doc = "\t\t\tthe third master. Can be NULL if only two masters are required."]
    #[doc = "\t\t\tSee attention below for more detail."]
    #[doc = " \\param cszP2PHostNameFourth [in] Specify the host name or IP address of"]
    #[doc = "\t\t\tthe fourth master. Can be NULL if only two masters are required."]
    #[doc = "\t\t\tSee attention below for more detail."]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR if initializing successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_RESOLVE_HOSTNAME Cannot resolve masters' host name"]
    #[doc = "\t\t\t- #IOTC_ER_ALREADY_INITIALIZED IOTC module is already initialized"]
    #[doc = "\t\t\t- #IOTC_ER_MASTER_TOO_FEW Two masters are required as parameters at minimum"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_MUTEX Fails to create Mutexs"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = ""]
    #[doc = " \\see IOTC_Initialize2(), IOTC_DeInitialize()"]
    #[doc = ""]
    #[doc = " \\attention   (1) This function is the key entry to whole IOTC platform, including"]
    #[doc = "\t\t\t\tRDT module and AV module. That means, if you want tso use"]
    #[doc = "\t\t\t\tRDT module, users shall still use this function to initialize IOTC"]
    #[doc = "\t\t\t\tmodule before calling RDT_Initialize(). <br><br>"]
    #[doc = "\t\t\t\t(2) Usually, host name is suggested to be used to specify a master."]
    #[doc = "\t\t\t\tbecause that will ensure devices and clients can still connect"]
    #[doc = "\t\t\t\tto masters even the network address configuration of masters"]
    #[doc = "\t\t\t\tchanges in the future. However, in rare case, the host name"]
    #[doc = "\t\t\t\tof masters can not be resolved due to network issue and it is"]
    #[doc = "\t\t\t\tnecessary to specify IP address of masters in this function"]
    #[doc = "\t\t\t\tin order for successful connection. The host name and IP address"]
    #[doc = "\t\t\t\tof each master is listed as below:"]
    #[doc = "\t\t\t\t- Master #1: m1.iotcplatform.com => 50.19.254.134"]
    #[doc = "\t\t\t\t- Master #2: m2.iotcplatform.com => 122.248.234.207"]
    #[doc = "\t\t\t\t- Master #3: m3.iotcplatform.com => 46.137.188.54"]
    #[doc = "\t\t\t\t- Master #4: m4.iotcplatform.com => 122.226.84.253"]
    #[doc = "\t\t\t\t- Master #5: m5.iotcplatform.com => 61.188.37.216"]
    pub fn IOTC_Initialize(
        nUDPPort: ::std::os::raw::c_ushort,
        cszP2PHostNamePrimary: *const ::std::os::raw::c_char,
        cszP2PHostNameSecondary: *const ::std::os::raw::c_char,
        cszP2PHostNameThird: *const ::std::os::raw::c_char,
        cszP2PHostNameFourth: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Initialize IOTC module"]
    #[doc = ""]
    #[doc = " \\details This function is used by devices or clients to initialize IOTC"]
    #[doc = "\t\t\tmodule and shall be called before\tany IOTC module related"]
    #[doc = "\t\t\tfunction is invoked except for IOTC_Set_Max_Session_Number()."]
    #[doc = "\t\t\t<br>"]
    #[doc = "\t\t\tThe different between this function and IOTC_Initialize() is this"]
    #[doc = "\t\t\tfunction uses following steps to connect masters (1) IP addresses"]
    #[doc = "\t\t\tof master (2) if fails to connect in step 1, resolve predefined"]
    #[doc = "\t\t\tdomain name of masters (3) try to connect again with the resolved"]
    #[doc = "\t\t\tIP address of step 2 if IP is resolved successfully."]
    #[doc = ""]
    #[doc = " \\param nUDPPort [in] Specify a UDP port. Random UDP port is used if it is specified as 0."]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR if initializing successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_RESOLVE_HOSTNAME Cannot resolve masters' host name"]
    #[doc = "\t\t\t- #IOTC_ER_ALREADY_INITIALIZED IOTC module is already initialized"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_MUTEX Fails to create Mutexs"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = ""]
    #[doc = " \\see IOTC_Initialize(), IOTC_DeInitialize()"]
    #[doc = ""]
    #[doc = " \\attention This function is the key entry to whole IOTC platform, including"]
    #[doc = "\t\t\t\tRDT module and AV module. That means, if you want to use"]
    #[doc = "\t\t\t\tRDT module, users shall still use this function to initialize IOTC"]
    #[doc = "\t\t\t\tmodule before calling RDT_Initialize()."]
    pub fn IOTC_Initialize2(nUDPPort: ::std::os::raw::c_ushort) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Deinitialize IOTC module"]
    #[doc = ""]
    #[doc = " \\details This function will deinitialize IOTC module."]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR if deinitialize successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED the IOTC module is not initialized yet."]
    #[doc = ""]
    #[doc = " \\see IOTC_Initialize(), IOTC_Initialize2()"]
    #[doc = ""]
    #[doc = " \\attention IOTC_DeInitialize() will automatically close all IOTC sessions"]
    #[doc = "\t\t\t\tin local site while the remote site will find sessions have"]
    #[doc = "\t\t\t\tbeen closed after certain period of time. Therefore, it is"]
    #[doc = "\t\t\t\tsuggested to close all sessions before invoking this function"]
    #[doc = "\t\t\t\tto ensure the remote site and real-time session status."]
    pub fn IOTC_DeInitialize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device to login to IOTC servers"]
    #[doc = ""]
    #[doc = " \\details This function will let a device login to IOTC servers. UID is required"]
    #[doc = "\t\t\twhen login to IOTC servers. The device name and password are applicable"]
    #[doc = "\t\t\tonly in LAN mode when the device cannot login to IOTC servers"]
    #[doc = "\t\t\tdue to network issue."]
    #[doc = ""]
    #[doc = " \\param cszUID [in] The UID of that device login to IOTC servers"]
    #[doc = " \\param cszDeviceName [in] The name of that device, used in LAN mode for clients"]
    #[doc = "\t\t\tto connect"]
    #[doc = " \\param cszDevicePWD [in] The password of that device, used in LAN mode for"]
    #[doc = "\t\t\tclients to connect"]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR if device had obtained server list and sent login packets successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_UNLICENSE The UID is not licensed or expired"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_LOGIN_ALREADY_CALLED The device is already under login process currently"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_SOCKET Fails to create sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_OPT Fails to set up socket options"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_BIND Fails to bind sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_RESOLVE_HOSTNAME Cannot resolve masters' host name"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_TRAVEL_FAILED Cannot connect to masters in neither UDP nor TCP"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED Cannot connect to IOTC servers in TCP"]
    #[doc = "\t\t\t- #IOTC_ER_NO_PERMISSION The device does not support TCP relay"]
    #[doc = "\t\t\t- #IOTC_ER_SERVER_NOT_RESPONSE IOTC servers have no response"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_GET_LOCAL_IP Fails to get the device's local IP address"]
    #[doc = "\t\t\t- #IOTC_ER_NETWORK_UNREACHABLE Network is unreachable"]
    #[doc = "\t\t\t- #IOTC_ER_NO_SERVER_LIST No IOTC server information while device login"]
    #[doc = ""]
    #[doc = " \\attention (1) This function is a block process. That means this function will return until"]
    #[doc = "\t\t\t\tthe device can login into IOTC servers successfully or some error happens"]
    #[doc = "\t\t\t\tduring the process. It is suggested to use another thread to perform"]
    #[doc = "\t\t\t\tlogin process so that sequential instructions will not blocked. <br><br>"]
    #[doc = "\t\t\t\t(2) Please use IOTC_Get_Login_Info() to check if device really logins"]
    #[doc = " \t\t\t\tinto server successfully."]
    pub fn IOTC_Device_Login(
        cszUID: *const ::std::os::raw::c_char,
        cszDeviceName: *const ::std::os::raw::c_char,
        cszDevicePWD: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device to get the login information"]
    #[doc = ""]
    #[doc = " \\details This function gets the login information of a device to IOTC servers."]
    #[doc = ""]
    #[doc = " \\param pnLoginInfo [out] The login info with meanings of following bits"]
    #[doc = "\t\t\t- bit 0: the device is ready for connection by client from LAN if this bit is 1"]
    #[doc = "\t\t\t- bit 1: the device is ready for connection by client from Internet if this bit is 1"]
    #[doc = "\t\t\t- bit 2: if this bit is 1, it means the device has received login"]
    #[doc = "\t\t\t\t\t\tresponse from IOTC servers since IOTC_Get_Login_Info()"]
    #[doc = "\t\t\t\t\t\tis called last time."]
    #[doc = ""]
    #[doc = " \\return The number of fails to login to IOTC servers."]
    #[doc = ""]
    pub fn IOTC_Get_Login_Info(pnLoginInfo: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device to get the login information"]
    #[doc = ""]
    #[doc = " \\details This function gets the login information of a device to IOTC servers. <br>"]
    #[doc = "\t\t\tThe difference of this function and IOTC_Get_Login_Info() is"]
    #[doc = "\t\t\tthis function will set callback function inside IOTC module and"]
    #[doc = "\t\t\tthat callback function will be invoked whenever the login status"]
    #[doc = "\t\t\tof that device is updated from IOTC servers, for example, IOTC"]
    #[doc = "\t\t\tservers response login message to that device or the connection"]
    #[doc = "\t\t\tbetween IOTC servers and that device has been lost."]
    #[doc = ""]
    #[doc = " \\param pfxLoginInfoFn [in] The function pointer to getting login info function"]
    #[doc = ""]
    pub fn IOTC_Get_Login_Info_ByCallBackFn(pfxLoginInfoFn: loginInfoCB);
}
extern "C" {
    #[doc = " \\brief Used by a device to listen connections from clients"]
    #[doc = ""]
    #[doc = " \\details This function is for a device to listen any connection from clients."]
    #[doc = "\t\t\tIf connection is established with the help of IOTC servers, the"]
    #[doc = "\t\t\tIOTC session ID will be returned in this function and then device and"]
    #[doc = "\t\t\tclient can communicate for the other later by using this IOTC session ID."]
    #[doc = ""]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of millisecond, give 0 means block forever"]
    #[doc = ""]
    #[doc = " \\return IOTC session ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_EXCEED_MAX_SESSION The number of IOTC sessions has reached maximum in device side"]
    #[doc = "\t\t\t- #IOTC_ER_LISTEN_ALREADY_CALLED The device is already in listen process"]
    #[doc = "\t\t\t- #IOTC_ER_TIMEOUT No connection is established from clients before timeout expires"]
    #[doc = "\t\t\t- #IOTC_ER_EXIT_LISTEN The device stops listening for connections from clients."]
    #[doc = ""]
    #[doc = " \\attention (1) This function is a block process, waiting for following two"]
    #[doc = "\t\t\t\tconditions happens before executing\tsequential instructions"]
    #[doc = "\t\t\t\t(a) any connection from clients is established (b) timeout expires.<br><br>"]
    #[doc = "\t\t\t\t(2) nTimeout has no effect in 8051 platform."]
    pub fn IOTC_Listen(nTimeout: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device to exit listen process"]
    #[doc = ""]
    #[doc = " \\details Since listen process is a block process and that means a device"]
    #[doc = "\t\t\twill wait for following two conditions happens before executing"]
    #[doc = "\t\t\tsequential instructions (1) any connection from clients is established"]
    #[doc = "\t\t\t(2) timeout expires. In some cases, users may want the device to"]
    #[doc = "\t\t\texit listen immediately by this function in another thread before"]
    #[doc = "\t\t\tthe two conditions above happens."]
    pub fn IOTC_Listen_Exit();
}
extern "C" {
    #[doc = " \\brief Used by a device to listen connections from clients"]
    #[doc = ""]
    #[doc = " \\details This function is for a device to listen any connection from clients."]
    #[doc = "\t\t\tIf connection is established with the help of IOTC servers, the"]
    #[doc = "\t\t\tIOTC session ID will be returned in this function and then device and"]
    #[doc = "\t\t\tclient can communicate for the other later by using this IOTC session ID."]
    #[doc = "\t\t\t<br> <br>"]
    #[doc = "\t\t\tThe difference between this function and IOTC_Listen() is that"]
    #[doc = "\t\t\tthis function supports IOTC session established in secure mode. Also,"]
    #[doc = "\t\t\tby specifying IOTC_ARBITRARY_MODE as IOTC session mode, this function can"]
    #[doc = "\t\t\tlet devices establish IOTC session in either non-secure mode and secure"]
    #[doc = "\t\t\tmode according to clients' request."]
    #[doc = ""]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of millisecond, give 0 means block forever"]
    #[doc = " \\param cszAESKey [in] The AES key for certification. Specify it as NULL will make"]
    #[doc = "\t\t\tIOTC module use predefined AES key."]
    #[doc = " \\param nSessionMode [in] The IOTC session mode that a device want to connect."]
    #[doc = "\t\t\tPlease refer to #IOTCSessionMode for more detail"]
    #[doc = ""]
    #[doc = " \\return IOTC session ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_EXCEED_MAX_SESSION The number of IOTC sessions has reached maximum in device side"]
    #[doc = "\t\t\t- #IOTC_ER_LISTEN_ALREADY_CALLED The device is already in listen process"]
    #[doc = "\t\t\t- #IOTC_ER_TIMEOUT No connection is established from clients before timeout expires"]
    #[doc = "\t\t\t- #IOTC_ER_EXIT_LISTEN The device stops listening for connections from clients."]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_MODE The IOTC session mode is not valid. Please refer to #IOTCSessionMode"]
    #[doc = "\t\t\t- #IOTC_ER_CLIENT_NOT_SECURE_MODE A client wants to connect to a device in"]
    #[doc = "\t\t\t\t\tnon-secure mode while that device supports secure mode only."]
    #[doc = "\t\t\t- #IOTC_ER_CLIENT_SECURE_MODE A client wants to connect to a device"]
    #[doc = "\t\t\t\t\tin secure mode while that device does not support secure mode."]
    #[doc = "\t\t\t- #IOTC_ER_AES_CERTIFY_FAIL The AES certification fails"]
    #[doc = ""]
    #[doc = " \\attention (1) This function is available on Win32, Linux, Android, iOS and ARC platforms.<br><br>"]
    #[doc = "\t\t\t\t(2) The AES key shall be matched between a device and a client"]
    #[doc = "\t\t\t\tin order to establish connection successfully."]
    pub fn IOTC_Listen2(
        nTimeout: ::std::os::raw::c_uint,
        cszAESKey: *const ::std::os::raw::c_char,
        nSessionMode: IOTCSessionMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a client to connect a device"]
    #[doc = ""]
    #[doc = " \\details This function is for a client to connect a device by specifying"]
    #[doc = "\t\t\tthe UID of that device. If connection is established with the"]
    #[doc = "\t\t\thelp of IOTC servers, the IOTC session ID will be returned in this"]
    #[doc = "\t\t\tfunction and then device and client can communicate for the other"]
    #[doc = "\t\t\tlater by using this IOTC session ID."]
    #[doc = ""]
    #[doc = " \\param cszUID [in] The UID of a device that client wants to connect"]
    #[doc = ""]
    #[doc = " \\return IOTC session ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_CONNECT_IS_CALLING The client is already connecting to a device"]
    #[doc = "\t\t\t- #IOTC_ER_UNLICENSE The specified UID of that device is not licensed or expired"]
    #[doc = "\t\t\t- #IOTC_ER_EXCEED_MAX_SESSION The number of IOTC sessions has reached maximum in client side"]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_NOT_LISTENING The device is not listening for connection now"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CONNECT_SEARCH The client stop connecting to the device"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_RESOLVE_HOSTNAME Cannot resolve masters' host name"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_TRAVEL_FAILED Cannot connect to masters in neither UDP nor TCP"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED Cannot connect to IOTC servers in TCP"]
    #[doc = "\t\t\t- #IOTC_ER_CAN_NOT_FIND_DEVICE IOTC servers cannot locate the specified device"]
    #[doc = "\t\t\t- #IOTC_ER_NO_PERMISSION The specified device does not support TCP relay"]
    #[doc = "\t\t\t- #IOTC_ER_SERVER_NOT_RESPONSE IOTC servers have no response"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_GET_LOCAL_IP Fails to get the client's local IP address"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SETUP_RELAY Fails to connect the device via relay mode"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_SOCKET Fails to create sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_OPT Fails to set up socket options"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_BIND Fails to bind sockets"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_SUPPORT_RELAY Not support relay connection by IOTC servers"]
    #[doc = "\t\t\t- #IOTC_ER_NO_SERVER_LIST No IOTC server information while client connect"]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_MULTI_LOGIN The connecting device duplicated loggin and may unconnectable"]
    #[doc = ""]
    #[doc = " \\attention This process is a block process."]
    #[doc = ""]
    pub fn IOTC_Connect_ByUID(cszUID: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a client to get a tutk_platform_free session ID."]
    #[doc = ""]
    #[doc = " \\details This function is for a client to get a tutk_platform_free session ID used for a parameter of"]
    #[doc = "          IOTC_Connect_ByUID_Parallel()."]
    #[doc = ""]
    #[doc = " \\return IOTC session ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_EXCEED_MAX_SESSION The number of IOTC sessions has reached maximum in client side"]
    #[doc = ""]
    #[doc = " \\attention (1) If you already get a session ID via this function must call IOTC_Connect_ByUID_Parallel() and then"]
    #[doc = "                 it will release session ID resource automatically when connection failed.<br><br>"]
    #[doc = "            (2) If you already get a session ID via this function and want to close it please use IOTC_Session_Close()."]
    pub fn IOTC_Get_SessionID() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a client to connect a device and bind to a specified session ID."]
    #[doc = ""]
    #[doc = " \\details This function is for a client to connect a device by specifying"]
    #[doc = "\t\t\tthe UID of that device, and bind to a tutk_platform_free session ID from IOTC_Get_SessionID()."]
    #[doc = " \t\t\tIf connection is established with the help of IOTC servers,"]
    #[doc = "\t\t\tthe #IOTC_ER_NoERROR will be returned in this function and then device and"]
    #[doc = "\t\t\tclient can communicate for the other later by using this IOTC session ID."]
    #[doc = "\t\t\tIf this function is called by multiple threads, the connections will be"]
    #[doc = "\t\t\tprocessed concurrently."]
    #[doc = ""]
    #[doc = " \\param cszUID [in] The UID of a device that client wants to connect"]
    #[doc = " \\param SID [in] The Session ID got from IOTC_Get_SessionID() the connection should bind to."]
    #[doc = ""]
    #[doc = " \\return IOTC session ID if return value >= 0 and equal to the input parameter SID."]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_UNLICENSE The specified UID of that device is not licensed or expired"]
    #[doc = "\t\t\t- #IOTC_ER_EXCEED_MAX_SESSION The number of IOTC sessions has reached maximum in client side"]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_NOT_LISTENING The device is not listening for connection now"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CONNECT_SEARCH The client stop connecting to the device"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_RESOLVE_HOSTNAME Cannot resolve masters' host name"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_TRAVEL_FAILED Cannot connect to masters in neither UDP nor TCP"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED Cannot connect to IOTC servers in TCP"]
    #[doc = "\t\t\t- #IOTC_ER_CAN_NOT_FIND_DEVICE IOTC servers cannot locate the specified device"]
    #[doc = "\t\t\t- #IOTC_ER_NO_PERMISSION The specified device does not support TCP relay"]
    #[doc = "\t\t\t- #IOTC_ER_SERVER_NOT_RESPONSE IOTC servers have no response"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_GET_LOCAL_IP Fails to get the client's local IP address"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SETUP_RELAY Fails to connect the device via relay mode"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_SOCKET Fails to create sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_OPT Fails to set up socket options"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_BIND Fails to bind sockets"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_SUPPORT_RELAY Not support relay connection by IOTC servers"]
    #[doc = "\t\t\t- #IOTC_ER_NO_SERVER_LIST No IOTC server information while client connect"]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_MULTI_LOGIN The connecting device duplicated loggin and may unconnectable"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = ""]
    #[doc = " \\attention If you call IOTC_Connect_Stop_BySID() and this function not return yet, and then use the same"]
    #[doc = "              session ID to call again will cause session ID in wrong status."]
    #[doc = ""]
    pub fn IOTC_Connect_ByUID_Parallel(
        cszUID: *const ::std::os::raw::c_char,
        SID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a client to connect a device"]
    #[doc = ""]
    #[doc = " \\details This function is for a client to connect a device by specifying"]
    #[doc = "\t\t\tthe UID of that device. If connection is established with the"]
    #[doc = "\t\t\thelp of IOTC servers, the IOTC session ID will be returned in this"]
    #[doc = "\t\t\tfunction and then device and client can communicate for the other"]
    #[doc = "\t\t\tlater by using this IOTC session ID."]
    #[doc = "\t\t\t<br> <br>"]
    #[doc = "\t\t\tThe different between this function and IOTC_Connect_ByUID() is"]
    #[doc = "\t\t\tthat this function supports IOTC session established in secure mode."]
    #[doc = "\t\t\tAlso, by specifying IOTC_ARBITRARY_MODE as IOTC session mode, this"]
    #[doc = "\t\t\tfunction can let clients establish IOTC session in either non-secure"]
    #[doc = "\t\t\tmode and secure\tmode according to devices' secure settings."]
    #[doc = ""]
    #[doc = " \\param cszUID [in] The UID of a device that client wants to connect"]
    #[doc = " \\param cszAESKey [in] The AES key for certification. Specify it as NULL will make"]
    #[doc = "\t\t\tIOTC module use predefined AES key."]
    #[doc = " \\param nSessionMode [in] The IOTC session mode that a client want to connect."]
    #[doc = "\t\t\tPlease refer to #IOTCSessionMode for more detail"]
    #[doc = ""]
    #[doc = " \\return IOTC session ID if return value >= 0"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_CONNECT_IS_CALLING The client is already connecting to a device"]
    #[doc = "\t\t\t- #IOTC_ER_UNLICENSE The specified UID of that device is not licensed or expired"]
    #[doc = "\t\t\t- #IOTC_ER_EXCEED_MAX_SESSION The number of IOTC sessions has reached maximum in client side"]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_NOT_LISTENING The device is not listening for connection now"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CONNECT_SEARCH The client stop connecting to the device"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_RESOLVE_HOSTNAME Cannot resolve masters' host name"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_THREAD Fails to create threads"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_TRAVEL_FAILED Cannot connect to masters in neither UDP nor TCP"]
    #[doc = "\t\t\t- #IOTC_ER_TCP_CONNECT_TO_SERVER_FAILED Cannot connect to IOTC servers in TCP"]
    #[doc = "\t\t\t- #IOTC_ER_CAN_NOT_FIND_DEVICE IOTC servers cannot locate the specified device"]
    #[doc = "\t\t\t- #IOTC_ER_NO_PERMISSION The specified device does not support TCP relay"]
    #[doc = "\t\t\t- #IOTC_ER_SERVER_NOT_RESPONSE IOTC servers have no response"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_GET_LOCAL_IP Fails to get the client's local IP address"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SETUP_RELAY Fails to connect the device via relay mode"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_MODE The IOTC session mode is not valid. Please refer to #IOTCSessionMode"]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_NOT_SECURE_MODE A client wants to connect to a device in"]
    #[doc = "\t\t\t\t\tsecure mode while that device supports non-secure mode only."]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_SECURE_MODE A client wants to connect to a device"]
    #[doc = "\t\t\t\t\tin non-secure mode while that device supports secure mode only."]
    #[doc = "\t\t\t- #IOTC_ER_AES_CERTIFY_FAIL The AES certification fails"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_SOCKET Fails to create sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_OPT Fails to set up socket options"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_BIND Fails to bind sockets"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_SUPPORT_RELAY Not support relay connection by IOTC servers"]
    #[doc = "\t\t\t- #IOTC_ER_NO_SERVER_LIST No IOTC server information while client connect"]
    #[doc = "\t\t\t- #IOTC_ER_DEVICE_MULTI_LOGIN The connecting device duplicated loggin and may unconnectable"]
    #[doc = ""]
    #[doc = " \\attention (1) This process is a block process.<br><br>"]
    #[doc = "\t\t\t\t(2) The AES key shall be matched between a device and a client in"]
    #[doc = "\t\t\t\torder to establish connection successfully.<br><br>"]
    #[doc = "\t\t\t\t(3) This function is available on Win32, Linux, Android, iOS and ARC platforms."]
    #[doc = ""]
    pub fn IOTC_Connect_ByUID2(
        cszUID: *const ::std::os::raw::c_char,
        cszAESKey: *const ::std::os::raw::c_char,
        nSessionMode: IOTCSessionMode,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a client to stop connecting a device"]
    #[doc = ""]
    #[doc = " \\details This function is for a client to stop connecting a device. Since"]
    #[doc = "\t\t\tIOTC_Connect_ByUID(), IOTC_Connect_ByUID2() are all block processes, that means"]
    #[doc = "\t\t\tthe client will have to wait for the return of these functions before"]
    #[doc = "\t\t\texecuting sequential instructions. In some cases, users may want"]
    #[doc = "\t\t\tthe client to stop connecting immediately by this function in"]
    #[doc = "\t\t\tanother thread before the return of connection process."]
    #[doc = ""]
    #[doc = " \\attention Only use to stop IOTC_Connect_ByUID() and 2, NOT use to stop IOTC_Connect_ByUID_Parallel()."]
    pub fn IOTC_Connect_Stop();
}
extern "C" {
    #[doc = " \\brief Used by a client to stop a specific session connecting a device"]
    #[doc = ""]
    #[doc = " \\details This function is for a client to stop connecting a device. Since"]
    #[doc = "\t\t\tIOTC_Connect_ByUID_Parallel() is a block processes, that means"]
    #[doc = "\t\t\tthe client will have to wait for the return of these functions before"]
    #[doc = "\t\t\texecuting sequential instructions. In some cases, users may want"]
    #[doc = "\t\t\tthe client to stop connecting immediately by this function in"]
    #[doc = "\t\t\tanother thread before the return of connection process."]
    #[doc = ""]
    #[doc = " \\param SID [in] The Session ID of a connection which will be stop."]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    pub fn IOTC_Connect_Stop_BySID(SID: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to read data from the other"]
    #[doc = ""]
    #[doc = " \\details A device or a client uses this function to read data through"]
    #[doc = "\t\t\ta specific IOTC channel in a IOTC session. <br>"]
    #[doc = "\t\t\tThe difference between this function and IOTC_Session_Read() is"]
    #[doc = "\t\t\tthis function provides packet lost information. Users may use"]
    #[doc = "\t\t\tthis to check how many packets, if any, have been lost since the last"]
    #[doc = "\t\t\ttime reading from this session."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to read data"]
    #[doc = " \\param abBuf [out] The array of byte buffer to receive read result"]
    #[doc = " \\param nMaxBufSize [in] The maximum length of the byte buffer"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of millisecond, give 0 means return immediately"]
    #[doc = " \\param pnPacketSN [out] The serial number of the packet that is read successfully"]
    #[doc = "\t\t\t\t\t\t\tthis time. Could be NULL."]
    #[doc = " \\param pbFlagLost [out] A boolean value to indicate if there are some packets"]
    #[doc = "\t\t\t\t\t\t\tlost between this time and previous successful read."]
    #[doc = "\t\t\t\t\t\t\tCould be NULL."]
    #[doc = " \\param nIOTCChannelID [in] The IOTC channel ID in this IOTC session to read data"]
    #[doc = ""]
    #[doc = " \\return The actual length of read result stored in abBuf if read successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_CH_NOT_ON The IOTC channel of specified channel ID is not turned on"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    #[doc = "\t\t\t- #IOTC_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\tread process is performed completely"]
    #[doc = ""]
    #[doc = " \\attention The IOTC channel of ID 0 is enabled by default when a IOTC session is established."]
    #[doc = "\t\t\t\tThat means nIOTCChannelID can be specified as 0 if only one IOTC channel"]
    #[doc = "\t\t\t\tis needed by the user. If more IOTC channels are required, users"]
    #[doc = "\t\t\t\tshould use IOTC_Session_Get_Free_Channel() and IOTC_Session_Channel_ON()"]
    #[doc = "\t\t\t\tto get more IOTC channel IDs and then specifying those IOTC channel IDs"]
    #[doc = "\t\t\t\tin this function according to the purpose defined by the user."]
    pub fn IOTC_Session_Read_Check_Lost(
        nIOTCSessionID: ::std::os::raw::c_int,
        abBuf: *mut ::std::os::raw::c_char,
        nMaxBufSize: ::std::os::raw::c_int,
        nTimeout: ::std::os::raw::c_uint,
        pnPacketSN: *mut ::std::os::raw::c_ushort,
        pbFlagLost: *mut ::std::os::raw::c_char,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to check the IOTC session info"]
    #[doc = ""]
    #[doc = " \\details A device or a client may use this function to check if the IOTC session"]
    #[doc = "\t\t\tis still alive as well as getting the IOTC session info."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to be checked"]
    #[doc = " \\param psSessionInfo [out] The session info of specified IOTC session"]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR if getting the IOTC session info successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    pub fn IOTC_Session_Check(
        nIOTCSessionID: ::std::os::raw::c_int,
        psSessionInfo: *mut st_SInfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to get the session status"]
    #[doc = ""]
    #[doc = " \\details This function gets the session status between device and client. <br>"]
    #[doc = "\t\t\tThe difference of this function and IOTC_Session_Check() is"]
    #[doc = "\t\t\tthis function will set callback function inside IOTC module and"]
    #[doc = "\t\t\tthat callback function will be invoked whenever the session status"]
    #[doc = "\t\t\tbetween device and client disconnected, for example, IOTC"]
    #[doc = "\t\t\talive timeout or one side call IOTC_Session_Close() to close"]
    #[doc = "\t\t\tthis session."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to check status"]
    #[doc = " \\param pfxSessionStatusFn [in] The function pointer to getting session status function"]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR if getting the IOTC session info successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    pub fn IOTC_Session_Check_ByCallBackFn(
        nIOTCSessionID: ::std::os::raw::c_int,
        pfxSessionStatusFn: sessionStatusCB,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to read data from the other"]
    #[doc = ""]
    #[doc = " \\details A device or a client uses this function to read data through"]
    #[doc = "\t\t\ta specific IOTC channel in a IOTC session."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to read data"]
    #[doc = " \\param abBuf [out] The array of byte buffer to receive read result"]
    #[doc = " \\param nMaxBufSize [in] The maximum length of the byte buffer"]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of millisecond, give 0 means return immediately"]
    #[doc = " \\param nIOTCChannelID [in] The IOTC channel ID in this IOTC session to read data"]
    #[doc = ""]
    #[doc = " \\return The actual length of read result stored in abBuf if read successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_CH_NOT_ON The IOTC channel of specified channel ID is not turned on"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    #[doc = "\t\t\t- #IOTC_ER_TIMEOUT The timeout specified by nTimeout expires before"]
    #[doc = "\t\t\t\tread process is performed completely"]
    #[doc = ""]
    #[doc = " \\attention (1) The IOTC channel of ID 0 is enabled by default when a IOTC session is established."]
    #[doc = "\t\t\t\tThat means nIOTCChannelID can be specified as 0 if only one IOTC channel"]
    #[doc = "\t\t\t\tis needed by the user. If more IOTC channels are required, users"]
    #[doc = "\t\t\t\tshould use IOTC_Session_Get_Free_Channel() and IOTC_Session_Channel_ON()"]
    #[doc = "\t\t\t\tto get more IOTC channel IDs and then specifying those IOTC channel IDs"]
    #[doc = "\t\t\t\tin this function according to the purpose defined by the user.<br><br>"]
    #[doc = "\t\t\t\t(2) If the size of abBuf, i.e. defined by nMaxBufSize, is less than"]
    #[doc = "\t\t\t\tthe size of data to be read, then this function will only read"]
    #[doc = "\t\t\t\tthe data up to nMaxBufSize and the remaining part will be truncated without"]
    #[doc = "\t\t\t\terror code returned. Therefore, it is suggested to allocate the size"]
    #[doc = "\t\t\t\tof abBuf as #IOTC_MAX_PACKET_SIZE for ensure complete reading."]
    #[doc = "\t\t\t\t(3) This function will need 192 bytes stack size."]
    #[doc = ""]
    pub fn IOTC_Session_Read(
        nIOTCSessionID: ::std::os::raw::c_int,
        abBuf: *mut ::std::os::raw::c_char,
        nMaxBufSize: ::std::os::raw::c_int,
        nTimeout: ::std::os::raw::c_uint,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to write data to the other"]
    #[doc = ""]
    #[doc = " \\details A device or a client uses this function to write data through"]
    #[doc = "\t\t\ta specific IOTC channel in a IOTC session."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to write data"]
    #[doc = " \\param cabBuf [in] The array of byte buffer containing the data to write."]
    #[doc = "\t\t\tIts size cannot be larger than #IOTC_MAX_PACKET_SIZE"]
    #[doc = " \\param nBufSize [in] The length of the byte buffer. It cannot be larger than"]
    #[doc = "\t\t\t#IOTC_MAX_PACKET_SIZE"]
    #[doc = " \\param nIOTCChannelID [in] The IOTC channel ID in this IOTC session to write data"]
    #[doc = ""]
    #[doc = " \\return The actual length of buffer to be written if write successfully. In non-blocking"]
    #[doc = "         mode, the length with zero usually means the socket buffer is full and unable to"]
    #[doc = "         write into."]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_CH_NOT_ON The IOTC channel of specified channel ID is not turned on"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    #[doc = ""]
    #[doc = " \\attention (1) The IOTC channel of ID 0 is enabled by default when a IOTC session is established."]
    #[doc = "\t\t\t\tThat means nIOTCChannelID can be specified as 0 if only one IOTC channel"]
    #[doc = "\t\t\t\tis needed by the user. If more IOTC channels are required, users"]
    #[doc = "\t\t\t\tshould use IOTC_Session_Get_Free_Channel() and IOTC_Session_Channel_ON()"]
    #[doc = "\t\t\t\tto get more IOTC channel IDs and then specifying those IOTC channel IDs"]
    #[doc = "\t\t\t\tin this function according to the purpose defined by the user. <br><br>"]
    #[doc = "\t\t\t\t(2) This function will block when session is connected via TCP and socket buffer is full."]
    #[doc = "\t\t\t\t(3) This function will need 4976 bytes stack size."]
    #[doc = ""]
    pub fn IOTC_Session_Write(
        nIOTCSessionID: ::std::os::raw::c_int,
        cabBuf: *const ::std::os::raw::c_char,
        nBufSize: ::std::os::raw::c_int,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to close a IOTC session"]
    #[doc = ""]
    #[doc = " \\details A device or a client uses this function to close a IOTC session"]
    #[doc = "\t\t\tspecified by its session ID if this IOTC session is no longer"]
    #[doc = "\t\t\trequired."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to be closed"]
    #[doc = ""]
    pub fn IOTC_Session_Close(nIOTCSessionID: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to get a tutk_platform_free IOTC channel"]
    #[doc = ""]
    #[doc = " \\details A device or a client uses this function to get a tutk_platform_free IOTC channel"]
    #[doc = "\t\t\tin a specified IOTC session. By default, IOTC channel of ID 0 is turned on"]
    #[doc = "\t\t\tonce a IOTC session is established. If more IOTC channels are required"]
    #[doc = "\t\t\tby users, this function can always return a tutk_platform_free IOTC channel until"]
    #[doc = "\t\t\tmaximum IOTC channels are reached."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to get tutk_platform_free IOTC channel"]
    #[doc = ""]
    #[doc = " \\return The IOTC channel ID of a tutk_platform_free IOTC channel if successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_NO_FREE_CHANNEL Already reach the maximum"]
    #[doc = "\t\t\t\tnumber of IOTC channels, no more tutk_platform_free IOTC channel is available"]
    #[doc = ""]
    #[doc = " \\attention (1) The IOTC channel returned by this function is already turned on.<br><br>"]
    #[doc = "\t\t\t\t(2) The IOTC channel is only turned on in the local site"]
    #[doc = "\t\t\t\tcalling\tthis function. That means, the remote site shall use"]
    #[doc = "\t\t\t\tIOTC_Session_Channel_ON() to turn on the same IOTC channel at its"]
    #[doc = "\t\t\t\tside before communication."]
    pub fn IOTC_Session_Get_Free_Channel(
        nIOTCSessionID: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to turn on a IOTC channel"]
    #[doc = ""]
    #[doc = " \\details A device or a client uses this function to turn on a IOTC channel"]
    #[doc = "\t\t\tbefore sending or receiving data through this IOTC channel."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session containing the"]
    #[doc = "\t\t\tIOTC channel to be turned on"]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the IOTC channel to be turned on"]
    #[doc = ""]
    #[doc = " \\return IOTC_ER_NoERROR if turning on the IOTC channel successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    #[doc = "\t\t\t- #IOTC_ER_CH_NOT_ON The specified IOTC channel ID is not valid"]
    #[doc = ""]
    #[doc = " \\attention The IOTC channel is only turned on in the local site calling"]
    #[doc = "\t\t\t\tthis function. That means, the remote site shall also use"]
    #[doc = "\t\t\t\tIOTC_Session_Channel_ON() to turn on the same IOTC channel"]
    #[doc = "\t\t\t\tat its side\tbefore communication."]
    pub fn IOTC_Session_Channel_ON(
        nIOTCSessionID: ::std::os::raw::c_int,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by a device or a client to turn off a IOTC channel"]
    #[doc = ""]
    #[doc = " \\details A device or a client uses this function to turn off a IOTC channel"]
    #[doc = "\t\t\twhen this IOTC channel is no longer needed for communication."]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session containing the"]
    #[doc = "\t\t\tIOTC channel to be turned off"]
    #[doc = " \\param nIOTCChannelID [in] The channel ID of the IOTC channel to be turned off"]
    #[doc = ""]
    #[doc = " \\return IOTC_ER_NoERROR if turning off the IOTC channel successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    #[doc = "\t\t\t- #IOTC_ER_CH_NOT_ON The specified IOTC channel ID is not valid"]
    #[doc = ""]
    #[doc = " \\attention (1) IOTC Channel 0 cannot be turned off because it is a default channel.<br><br>"]
    #[doc = "\t\t\t\t(2) Turn off a IOTC channel will also make the data remaining"]
    #[doc = "\t\t\t\tin receiving queue of this channel be deleted."]
    pub fn IOTC_Session_Channel_OFF(
        nIOTCSessionID: ::std::os::raw::c_int,
        nIOTCChannelID: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Used by search devices in LAN."]
    #[doc = ""]
    #[doc = " \\details When clients and devices are stay in a LAN environment, client can call this function"]
    #[doc = "\t\t\tto discovery devices and connect it directly."]
    #[doc = ""]
    #[doc = " \\param psLanSearchInfo [in] The array of struct st_LanSearchInfo to store search result"]
    #[doc = ""]
    #[doc = " \\param nArrayLen [in] The size of the psLanSearchInfo array"]
    #[doc = ""]
    #[doc = " \\param nWaitTimeMs [in] The timeout in milliseconds before discovery process end."]
    #[doc = ""]
    #[doc = " \\return IOTC_ER_NoERROR if search devices in LAN successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_ARG The arguments passed in to this function is invalid."]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_SOCKET Fails to create sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_OPT Fails to set up socket options"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_BIND Fails to bind sockets"]
    pub fn IOTC_Lan_Search(
        psLanSearchInfo: *mut st_LanSearchInfo,
        nArrayLen: ::std::os::raw::c_int,
        nWaitTimeMs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set path of log file"]
    #[doc = ""]
    #[doc = " \\details Set the absolute path of log file"]
    #[doc = ""]
    #[doc = " \\param path [in] The path of log file, NULL = disable Log"]
    #[doc = ""]
    #[doc = " \\param nMaxSize [in] The maximum size of log file in Bytes, 0 = unlimit"]
    #[doc = ""]
    pub fn IOTC_Set_Log_Path(path: *mut ::std::os::raw::c_char, nMaxSize: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " \\brief Set partial encode On/Off"]
    #[doc = ""]
    #[doc = " \\details Set partial encode On/Off"]
    #[doc = ""]
    #[doc = " \\param nIOTCSessionID [in] The session ID of the IOTC session to be encrypted."]
    #[doc = ""]
    #[doc = " \\param bPartialEncryption [in] 1: Enable partial encode, 0: Disable partial encode"]
    #[doc = ""]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_INITIALIZED The IOTC module is not initialized yet"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_SID The specified IOTC session ID is not valid"]
    #[doc = "\t\t\t- #IOTC_ER_SESSION_CLOSE_BY_REMOTE The IOTC session of specified"]
    #[doc = "\t\t\t\tsession ID has been closed by remote site"]
    #[doc = "\t\t\t- #IOTC_ER_REMOTE_TIMEOUT_DISCONNECT The timeout defined by #IOTC_SESSION_ALIVE_TIMEOUT"]
    #[doc = "\t\t\t\texpires because\tremote site has no response"]
    #[doc = "\t\t\t- #IOTC_ER_NOT_SUPPORT_PE The remote device don't support partial encryption"]
    #[doc = ""]
    pub fn IOTC_Set_Partial_Encryption(
        nIOTCSessionID: ::std::os::raw::c_int,
        bPartialEncryption: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Set device name."]
    #[doc = ""]
    #[doc = " \\details Device can let client know its name when client call IOTC_Lan_Search2()."]
    #[doc = "          The maximum size of device name is 128 Byte. We filled in 0 at the 129th Byte."]
    #[doc = ""]
    #[doc = " \\param cszDeviceName  [in] This is user-defined device name. Clients will get it by calling IOTC_Lan_Search2()."]
    #[doc = ""]
    pub fn IOTC_Set_Device_Name(cszDeviceName: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Used for searching devices in LAN."]
    #[doc = ""]
    #[doc = " \\details When client and devices are in LAN, client can search devices and their name"]
    #[doc = "\t\t\tby calling this function."]
    #[doc = ""]
    #[doc = " \\param psLanSearchInfo2 [in] The array of struct st_LanSearchInfo2 store the search result and Device name."]
    #[doc = ""]
    #[doc = " \\param nArrayLen [in] The size of psLanSearchInfo2 array"]
    #[doc = ""]
    #[doc = " \\param nWaitTimeMs [in] Period (or timeout) of searching LAN. (milliseconds)"]
    #[doc = ""]
    #[doc = " \\return IOTC_ER_NoERROR if search devices in LAN successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_INVALID_ARG The arguments passed in to this function is invalid."]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_SOCKET Fails to create sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_OPT Fails to set up socket options"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_BIND Fails to bind sockets"]
    pub fn IOTC_Lan_Search2(
        psLanSearchInfo2: *mut st_LanSearchInfo2,
        nArrayLen: ::std::os::raw::c_int,
        nWaitTimeMs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Turn on only TCP relay mode function."]
    #[doc = ""]
    #[doc = " \\details When device call this will login via TCP and only can be connected via LAN or TCP relay mode."]
    #[doc = "\t\t\tWhen client call this will connect to device only via LAN or TCP relay mode."]
    #[doc = ""]
    #[doc = " \\attention\tCan be called anywhere."]
    #[doc = ""]
    pub fn IOTC_TCPRelayOnly_TurnOn();
}
extern "C" {
    #[doc = " \\brief Setup LAN search and LAN connection timeout"]
    #[doc = ""]
    #[doc = " \\details Only client can call this, it can determine how many time to try LAN search and LAN connection."]
    #[doc = "\t\t\tOnce it called the timeout value is effective forever until IOTC_DeInitialize() be called."]
    #[doc = ""]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of millisecond, give 0 means skip LAN flow"]
    #[doc = ""]
    #[doc = " \\attention\tMast be called before start connection. Minimum is 100 millisecond."]
    #[doc = ""]
    pub fn IOTC_Setup_LANConnection_Timeout(nTimeout: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " \\brief Setup P2P connection timeout"]
    #[doc = ""]
    #[doc = " \\details Only client can call this, it can determine how many time to try P2P connection."]
    #[doc = "\t\t\tOnce it called the timeout value is effective forever until IOTC_DeInitialize() be called."]
    #[doc = ""]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of millisecond, give 0 means skip P2P flow"]
    #[doc = ""]
    #[doc = " \\attention\tMast be called before start connection. Minimum is 100 millisecond."]
    pub fn IOTC_Setup_P2PConnection_Timeout(nTimeout: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " \\brief ReInitialize IOTC module socket"]
    #[doc = ""]
    #[doc = " \\details This function will reopen P2P UDP socket of IOTC module."]
    #[doc = "\t\t\tIt is useful for iOS APP from backgroud to foreground will cause socket failed."]
    #[doc = ""]
    #[doc = " \\param nUDPPort [in] Specify a UDP port. Random UDP port is used if it is specified as 0."]
    #[doc = ""]
    #[doc = " \\return #IOTC_ER_NoERROR if initializing successfully"]
    #[doc = " \\return Error code if return value < 0"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_CREATE_SOCKET Fails to create sockets"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_OPT Fails to set up socket options"]
    #[doc = "\t\t\t- #IOTC_ER_FAIL_SOCKET_BIND Fails to bind sockets"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " \\attention   Must call it before any connection process."]
    #[doc = ""]
    pub fn IOTC_ReInitSocket(nUDPPort: ::std::os::raw::c_ushort) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Setup detect network reachable timeout"]
    #[doc = ""]
    #[doc = " \\details Both device and client can call this, it can determine how many time to detect internet reachable."]
    #[doc = "\t\t\tOnce it called the timeout value is effective forever until IOTC_DeInitialize() be called."]
    #[doc = ""]
    #[doc = " \\param nTimeout [in] The timeout for this function in unit of millisecond"]
    #[doc = ""]
    #[doc = " \\attention\tMast be called before start login or connection."]
    #[doc = ""]
    pub fn IOTC_Setup_DetectNetwork_Timeout(nTimeout: ::std::os::raw::c_uint);
}
pub const ENUM_CODECID_MEDIA_CODEC_UNKNOWN: ENUM_CODECID = 0;
pub const ENUM_CODECID_MEDIA_CODEC_VIDEO_MPEG4: ENUM_CODECID = 76;
pub const ENUM_CODECID_MEDIA_CODEC_VIDEO_H263: ENUM_CODECID = 77;
pub const ENUM_CODECID_MEDIA_CODEC_VIDEO_H264: ENUM_CODECID = 78;
pub const ENUM_CODECID_MEDIA_CODEC_VIDEO_MJPEG: ENUM_CODECID = 79;
pub const ENUM_CODECID_MEDIA_CODEC_VIDEO_H265: ENUM_CODECID = 80;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_AAC: ENUM_CODECID = 136;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_G711U: ENUM_CODECID = 137;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_G711A: ENUM_CODECID = 138;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_ADPCM: ENUM_CODECID = 139;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_PCM: ENUM_CODECID = 140;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_SPEEX: ENUM_CODECID = 141;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_MP3: ENUM_CODECID = 142;
pub const ENUM_CODECID_MEDIA_CODEC_AUDIO_G726: ENUM_CODECID = 143;
pub type ENUM_CODECID = ::std::os::raw::c_uint;
pub const ENUM_FRAMEFLAG_IPC_FRAME_FLAG_PBFRAME: ENUM_FRAMEFLAG = 0;
pub const ENUM_FRAMEFLAG_IPC_FRAME_FLAG_IFRAME: ENUM_FRAMEFLAG = 1;
pub const ENUM_FRAMEFLAG_IPC_FRAME_FLAG_MD: ENUM_FRAMEFLAG = 2;
pub const ENUM_FRAMEFLAG_IPC_FRAME_FLAG_IO: ENUM_FRAMEFLAG = 3;
pub type ENUM_FRAMEFLAG = ::std::os::raw::c_uint;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_8K: ENUM_AUDIO_SAMPLERATE = 0;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_11K: ENUM_AUDIO_SAMPLERATE = 1;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_12K: ENUM_AUDIO_SAMPLERATE = 2;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_16K: ENUM_AUDIO_SAMPLERATE = 3;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_22K: ENUM_AUDIO_SAMPLERATE = 4;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_24K: ENUM_AUDIO_SAMPLERATE = 5;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_32K: ENUM_AUDIO_SAMPLERATE = 6;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_44K: ENUM_AUDIO_SAMPLERATE = 7;
pub const ENUM_AUDIO_SAMPLERATE_AUDIO_SAMPLE_48K: ENUM_AUDIO_SAMPLERATE = 8;
pub type ENUM_AUDIO_SAMPLERATE = ::std::os::raw::c_uint;
pub const ENUM_AUDIO_DATABITS_AUDIO_DATABITS_8: ENUM_AUDIO_DATABITS = 0;
pub const ENUM_AUDIO_DATABITS_AUDIO_DATABITS_16: ENUM_AUDIO_DATABITS = 1;
pub type ENUM_AUDIO_DATABITS = ::std::os::raw::c_uint;
pub const ENUM_AUDIO_CHANNEL_AUDIO_CHANNEL_MONO: ENUM_AUDIO_CHANNEL = 0;
pub const ENUM_AUDIO_CHANNEL_AUDIO_CHANNEL_STERO: ENUM_AUDIO_CHANNEL = 1;
pub type ENUM_AUDIO_CHANNEL = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FRAMEINFO {
    pub codec_id: ::std::os::raw::c_ushort,
    pub flags: ::std::os::raw::c_uchar,
    pub cam_index: ::std::os::raw::c_uchar,
    pub onlineNum: ::std::os::raw::c_uchar,
    pub reserve1: [::std::os::raw::c_uchar; 3usize],
    pub reserve2: ::std::os::raw::c_uint,
    pub timestamp: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__FRAMEINFO() {
    assert_eq!(
        ::std::mem::size_of::<_FRAMEINFO>(),
        16usize,
        concat!("Size of: ", stringify!(_FRAMEINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_FRAMEINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_FRAMEINFO))
    );
    fn test_field_codec_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FRAMEINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).codec_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_FRAMEINFO),
                "::",
                stringify!(codec_id)
            )
        );
    }
    test_field_codec_id();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FRAMEINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(_FRAMEINFO),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_cam_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FRAMEINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cam_index) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(_FRAMEINFO),
                "::",
                stringify!(cam_index)
            )
        );
    }
    test_field_cam_index();
    fn test_field_onlineNum() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FRAMEINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).onlineNum) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_FRAMEINFO),
                "::",
                stringify!(onlineNum)
            )
        );
    }
    test_field_onlineNum();
    fn test_field_reserve1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FRAMEINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserve1) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(_FRAMEINFO),
                "::",
                stringify!(reserve1)
            )
        );
    }
    test_field_reserve1();
    fn test_field_reserve2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FRAMEINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserve2) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_FRAMEINFO),
                "::",
                stringify!(reserve2)
            )
        );
    }
    test_field_reserve2();
    fn test_field_timestamp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FRAMEINFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_FRAMEINFO),
                "::",
                stringify!(timestamp)
            )
        );
    }
    test_field_timestamp();
}
pub type FRAMEINFO_t = _FRAMEINFO;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_START: ENUM_AVIOCTRL_MSGTYPE = 511;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_STOP: ENUM_AVIOCTRL_MSGTYPE = 767;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_AUDIOSTART: ENUM_AVIOCTRL_MSGTYPE = 768;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_AUDIOSTOP: ENUM_AVIOCTRL_MSGTYPE = 769;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SPEAKERSTART: ENUM_AVIOCTRL_MSGTYPE = 848;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SPEAKERSTOP: ENUM_AVIOCTRL_MSGTYPE = 849;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETSTREAMCTRL_REQ: ENUM_AVIOCTRL_MSGTYPE = 800;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETSTREAMCTRL_RESP: ENUM_AVIOCTRL_MSGTYPE = 801;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETSTREAMCTRL_REQ: ENUM_AVIOCTRL_MSGTYPE = 802;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETSTREAMCTRL_RESP: ENUM_AVIOCTRL_MSGTYPE = 803;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETMOTIONDETECT_REQ: ENUM_AVIOCTRL_MSGTYPE = 804;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETMOTIONDETECT_RESP: ENUM_AVIOCTRL_MSGTYPE = 805;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETMOTIONDETECT_REQ: ENUM_AVIOCTRL_MSGTYPE = 806;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETMOTIONDETECT_RESP: ENUM_AVIOCTRL_MSGTYPE = 807;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETSUPPORTSTREAM_REQ: ENUM_AVIOCTRL_MSGTYPE = 808;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETSUPPORTSTREAM_RESP: ENUM_AVIOCTRL_MSGTYPE =
    809;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_DEVINFO_REQ: ENUM_AVIOCTRL_MSGTYPE = 816;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_DEVINFO_RESP: ENUM_AVIOCTRL_MSGTYPE = 817;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETPASSWORD_REQ: ENUM_AVIOCTRL_MSGTYPE = 818;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETPASSWORD_RESP: ENUM_AVIOCTRL_MSGTYPE = 819;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_LISTWIFIAP_REQ: ENUM_AVIOCTRL_MSGTYPE = 832;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_LISTWIFIAP_RESP: ENUM_AVIOCTRL_MSGTYPE = 833;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETWIFI_REQ: ENUM_AVIOCTRL_MSGTYPE = 834;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETWIFI_RESP: ENUM_AVIOCTRL_MSGTYPE = 835;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETWIFI_REQ: ENUM_AVIOCTRL_MSGTYPE = 836;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETWIFI_RESP: ENUM_AVIOCTRL_MSGTYPE = 837;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETWIFI_REQ_2: ENUM_AVIOCTRL_MSGTYPE = 838;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETWIFI_RESP_2: ENUM_AVIOCTRL_MSGTYPE = 839;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETRECORD_REQ: ENUM_AVIOCTRL_MSGTYPE = 784;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETRECORD_RESP: ENUM_AVIOCTRL_MSGTYPE = 785;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETRECORD_REQ: ENUM_AVIOCTRL_MSGTYPE = 786;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETRECORD_RESP: ENUM_AVIOCTRL_MSGTYPE = 787;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETRCD_DURATION_REQ: ENUM_AVIOCTRL_MSGTYPE = 788;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SETRCD_DURATION_RESP: ENUM_AVIOCTRL_MSGTYPE = 789;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETRCD_DURATION_REQ: ENUM_AVIOCTRL_MSGTYPE = 790;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETRCD_DURATION_RESP: ENUM_AVIOCTRL_MSGTYPE = 791;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_LISTEVENT_REQ: ENUM_AVIOCTRL_MSGTYPE = 792;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_LISTEVENT_RESP: ENUM_AVIOCTRL_MSGTYPE = 793;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL: ENUM_AVIOCTRL_MSGTYPE = 794;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_RECORD_PLAYCONTROL_RESP: ENUM_AVIOCTRL_MSGTYPE =
    795;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETAUDIOOUTFORMAT_REQ: ENUM_AVIOCTRL_MSGTYPE =
    810;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GETAUDIOOUTFORMAT_RESP: ENUM_AVIOCTRL_MSGTYPE =
    811;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_EVENTCONFIG_REQ: ENUM_AVIOCTRL_MSGTYPE = 1024;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_EVENTCONFIG_RESP: ENUM_AVIOCTRL_MSGTYPE =
    1025;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_EVENTCONFIG_REQ: ENUM_AVIOCTRL_MSGTYPE = 1026;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_EVENTCONFIG_RESP: ENUM_AVIOCTRL_MSGTYPE =
    1027;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_ENVIRONMENT_REQ: ENUM_AVIOCTRL_MSGTYPE = 864;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_ENVIRONMENT_RESP: ENUM_AVIOCTRL_MSGTYPE = 865;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_ENVIRONMENT_REQ: ENUM_AVIOCTRL_MSGTYPE = 866;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_ENVIRONMENT_RESP: ENUM_AVIOCTRL_MSGTYPE = 867;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_VIDEOMODE_REQ: ENUM_AVIOCTRL_MSGTYPE = 880;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_VIDEOMODE_RESP: ENUM_AVIOCTRL_MSGTYPE = 881;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_VIDEOMODE_REQ: ENUM_AVIOCTRL_MSGTYPE = 882;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_VIDEOMODE_RESP: ENUM_AVIOCTRL_MSGTYPE = 883;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_FORMATEXTSTORAGE_REQ: ENUM_AVIOCTRL_MSGTYPE = 896;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_FORMATEXTSTORAGE_RESP: ENUM_AVIOCTRL_MSGTYPE =
    897;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_PTZ_COMMAND: ENUM_AVIOCTRL_MSGTYPE = 4097;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_EVENT_REPORT: ENUM_AVIOCTRL_MSGTYPE = 8191;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_RECEIVE_FIRST_IFRAME: ENUM_AVIOCTRL_MSGTYPE =
    4098;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_FLOWINFO_REQ: ENUM_AVIOCTRL_MSGTYPE = 912;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_FLOWINFO_RESP: ENUM_AVIOCTRL_MSGTYPE = 913;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_CURRENT_FLOWINFO: ENUM_AVIOCTRL_MSGTYPE = 914;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_TIMEZONE_REQ: ENUM_AVIOCTRL_MSGTYPE = 928;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_TIMEZONE_RESP: ENUM_AVIOCTRL_MSGTYPE = 929;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_TIMEZONE_REQ: ENUM_AVIOCTRL_MSGTYPE = 944;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_TIMEZONE_RESP: ENUM_AVIOCTRL_MSGTYPE = 945;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_SAVE_DROPBOX_REQ: ENUM_AVIOCTRL_MSGTYPE =
    1280;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_GET_SAVE_DROPBOX_RESP: ENUM_AVIOCTRL_MSGTYPE =
    1281;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_SAVE_DROPBOX_REQ: ENUM_AVIOCTRL_MSGTYPE =
    1282;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_IPCAM_SET_SAVE_DROPBOX_RESP: ENUM_AVIOCTRL_MSGTYPE =
    1283;
pub const ENUM_AVIOCTRL_MSGTYPE_IOTYPE_USER_CMD_MAX: ENUM_AVIOCTRL_MSGTYPE = 1284;
#[doc = ""]
#[doc = " Message Type Define//////////////////////////////////////////"]
#[doc = ""]
pub type ENUM_AVIOCTRL_MSGTYPE = ::std::os::raw::c_uint;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_OK: ENUM_AVIOCTRL_ERROR = 0;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR: ENUM_AVIOCTRL_ERROR = -1;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_PASSWORD: ENUM_AVIOCTRL_ERROR = -2;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_STREAMCTRL: ENUM_AVIOCTRL_ERROR = -3;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_MONTIONDETECT: ENUM_AVIOCTRL_ERROR = -4;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_DEVICEINFO: ENUM_AVIOCTRL_ERROR = -5;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_LOGIN: ENUM_AVIOCTRL_ERROR = -6;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_LISTWIFIAP: ENUM_AVIOCTRL_ERROR = -7;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_SETWIFI: ENUM_AVIOCTRL_ERROR = -8;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_GETWIFI: ENUM_AVIOCTRL_ERROR = -9;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_SETRECORD: ENUM_AVIOCTRL_ERROR = -10;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_SETRCDDURA: ENUM_AVIOCTRL_ERROR = -11;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_LISTEVENT: ENUM_AVIOCTRL_ERROR = -12;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_PLAYBACK: ENUM_AVIOCTRL_ERROR = -13;
pub const ENUM_AVIOCTRL_ERROR_AVIOCTRL_ERR_INVALIDCHANNEL: ENUM_AVIOCTRL_ERROR = -33;
#[doc = ""]
#[doc = " Type ENUM Define ////////////////////////////////////////////"]
#[doc = ""]
pub type ENUM_AVIOCTRL_ERROR = ::std::os::raw::c_int;
pub const ENUM_SERVICE_TYPE_SERVTYPE_IPCAM_DWH: ENUM_SERVICE_TYPE = 0;
pub const ENUM_SERVICE_TYPE_SERVTYPE_RAS_DWF: ENUM_SERVICE_TYPE = 1;
pub const ENUM_SERVICE_TYPE_SERVTYPE_IOTCAM_8125: ENUM_SERVICE_TYPE = 16;
pub const ENUM_SERVICE_TYPE_SERVTYPE_IOTCAM_8125PT: ENUM_SERVICE_TYPE = 17;
pub const ENUM_SERVICE_TYPE_SERVTYPE_IOTCAM_8126: ENUM_SERVICE_TYPE = 18;
pub const ENUM_SERVICE_TYPE_SERVTYPE_IOTCAM_8126PT: ENUM_SERVICE_TYPE = 19;
pub type ENUM_SERVICE_TYPE = ::std::os::raw::c_uint;
pub const ENUM_QUALITY_LEVEL_AVIOCTRL_QUALITY_UNKNOWN: ENUM_QUALITY_LEVEL = 0;
pub const ENUM_QUALITY_LEVEL_AVIOCTRL_QUALITY_MAX: ENUM_QUALITY_LEVEL = 1;
pub const ENUM_QUALITY_LEVEL_AVIOCTRL_QUALITY_HIGH: ENUM_QUALITY_LEVEL = 2;
pub const ENUM_QUALITY_LEVEL_AVIOCTRL_QUALITY_MIDDLE: ENUM_QUALITY_LEVEL = 3;
pub const ENUM_QUALITY_LEVEL_AVIOCTRL_QUALITY_LOW: ENUM_QUALITY_LEVEL = 4;
pub const ENUM_QUALITY_LEVEL_AVIOCTRL_QUALITY_MIN: ENUM_QUALITY_LEVEL = 5;
pub type ENUM_QUALITY_LEVEL = ::std::os::raw::c_uint;
pub const ENUM_AP_MODE_AVIOTC_WIFIAPMODE_NULL: ENUM_AP_MODE = 0;
pub const ENUM_AP_MODE_AVIOTC_WIFIAPMODE_MANAGED: ENUM_AP_MODE = 1;
pub const ENUM_AP_MODE_AVIOTC_WIFIAPMODE_ADHOC: ENUM_AP_MODE = 2;
pub type ENUM_AP_MODE = ::std::os::raw::c_uint;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_INVALID: ENUM_AP_ENCTYPE = 0;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_NONE: ENUM_AP_ENCTYPE = 1;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WEP: ENUM_AP_ENCTYPE = 2;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA_TKIP: ENUM_AP_ENCTYPE = 3;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA_AES: ENUM_AP_ENCTYPE = 4;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA2_TKIP: ENUM_AP_ENCTYPE = 5;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA2_AES: ENUM_AP_ENCTYPE = 6;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA_PSK_TKIP: ENUM_AP_ENCTYPE = 7;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA_PSK_AES: ENUM_AP_ENCTYPE = 8;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA2_PSK_TKIP: ENUM_AP_ENCTYPE = 9;
pub const ENUM_AP_ENCTYPE_AVIOTC_WIFIAPENC_WPA2_PSK_AES: ENUM_AP_ENCTYPE = 10;
pub type ENUM_AP_ENCTYPE = ::std::os::raw::c_uint;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_ALL: ENUM_EVENTTYPE = 0;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_MOTIONDECT: ENUM_EVENTTYPE = 1;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_VIDEOLOST: ENUM_EVENTTYPE = 2;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_IOALARM: ENUM_EVENTTYPE = 3;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_MOTIONPASS: ENUM_EVENTTYPE = 4;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_VIDEORESUME: ENUM_EVENTTYPE = 5;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_IOALARMPASS: ENUM_EVENTTYPE = 6;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_EXPT_REBOOT: ENUM_EVENTTYPE = 16;
pub const ENUM_EVENTTYPE_AVIOCTRL_EVENT_SDFAULT: ENUM_EVENTTYPE = 17;
pub type ENUM_EVENTTYPE = ::std::os::raw::c_uint;
pub const ENUM_RECORD_TYPE_AVIOTC_RECORDTYPE_OFF: ENUM_RECORD_TYPE = 0;
pub const ENUM_RECORD_TYPE_AVIOTC_RECORDTYPE_FULLTIME: ENUM_RECORD_TYPE = 1;
pub const ENUM_RECORD_TYPE_AVIOTC_RECORDTYPE_ALARM: ENUM_RECORD_TYPE = 2;
pub const ENUM_RECORD_TYPE_AVIOTC_RECORDTYPE_MANUAL: ENUM_RECORD_TYPE = 3;
pub type ENUM_RECORD_TYPE = ::std::os::raw::c_uint;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_PAUSE: ENUM_PLAYCONTROL = 0;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_STOP: ENUM_PLAYCONTROL = 1;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_STEPFORWARD: ENUM_PLAYCONTROL = 2;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_STEPBACKWARD: ENUM_PLAYCONTROL = 3;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_FORWARD: ENUM_PLAYCONTROL = 4;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_BACKWARD: ENUM_PLAYCONTROL = 5;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_SEEKTIME: ENUM_PLAYCONTROL = 6;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_END: ENUM_PLAYCONTROL = 7;
pub const ENUM_PLAYCONTROL_AVIOCTRL_RECORD_PLAY_START: ENUM_PLAYCONTROL = 16;
pub type ENUM_PLAYCONTROL = ::std::os::raw::c_uint;
pub const ENUM_ENVIRONMENT_MODE_AVIOCTRL_ENVIRONMENT_INDOOR_50HZ: ENUM_ENVIRONMENT_MODE = 0;
pub const ENUM_ENVIRONMENT_MODE_AVIOCTRL_ENVIRONMENT_INDOOR_60HZ: ENUM_ENVIRONMENT_MODE = 1;
pub const ENUM_ENVIRONMENT_MODE_AVIOCTRL_ENVIRONMENT_OUTDOOR: ENUM_ENVIRONMENT_MODE = 2;
pub const ENUM_ENVIRONMENT_MODE_AVIOCTRL_ENVIRONMENT_NIGHT: ENUM_ENVIRONMENT_MODE = 3;
pub type ENUM_ENVIRONMENT_MODE = ::std::os::raw::c_uint;
pub const ENUM_VIDEO_MODE_AVIOCTRL_VIDEOMODE_NORMAL: ENUM_VIDEO_MODE = 0;
pub const ENUM_VIDEO_MODE_AVIOCTRL_VIDEOMODE_FLIP: ENUM_VIDEO_MODE = 1;
pub const ENUM_VIDEO_MODE_AVIOCTRL_VIDEOMODE_MIRROR: ENUM_VIDEO_MODE = 2;
pub const ENUM_VIDEO_MODE_AVIOCTRL_VIDEOMODE_FLIP_MIRROR: ENUM_VIDEO_MODE = 3;
pub type ENUM_VIDEO_MODE = ::std::os::raw::c_uint;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_STOP: ENUM_PTZCMD = 0;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_UP: ENUM_PTZCMD = 1;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_DOWN: ENUM_PTZCMD = 2;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_LEFT: ENUM_PTZCMD = 3;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_LEFT_UP: ENUM_PTZCMD = 4;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_LEFT_DOWN: ENUM_PTZCMD = 5;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_RIGHT: ENUM_PTZCMD = 6;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_RIGHT_UP: ENUM_PTZCMD = 7;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_RIGHT_DOWN: ENUM_PTZCMD = 8;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_AUTO: ENUM_PTZCMD = 9;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_SET_POINT: ENUM_PTZCMD = 10;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_CLEAR_POINT: ENUM_PTZCMD = 11;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_GOTO_POINT: ENUM_PTZCMD = 12;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_SET_MODE_START: ENUM_PTZCMD = 13;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_SET_MODE_STOP: ENUM_PTZCMD = 14;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_MODE_RUN: ENUM_PTZCMD = 15;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_MENU_OPEN: ENUM_PTZCMD = 16;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_MENU_EXIT: ENUM_PTZCMD = 17;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_MENU_ENTER: ENUM_PTZCMD = 18;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_FLIP: ENUM_PTZCMD = 19;
pub const ENUM_PTZCMD_AVIOCTRL_PTZ_START: ENUM_PTZCMD = 20;
pub const ENUM_PTZCMD_AVIOCTRL_LENS_APERTURE_OPEN: ENUM_PTZCMD = 21;
pub const ENUM_PTZCMD_AVIOCTRL_LENS_APERTURE_CLOSE: ENUM_PTZCMD = 22;
pub const ENUM_PTZCMD_AVIOCTRL_LENS_ZOOM_IN: ENUM_PTZCMD = 23;
pub const ENUM_PTZCMD_AVIOCTRL_LENS_ZOOM_OUT: ENUM_PTZCMD = 24;
pub const ENUM_PTZCMD_AVIOCTRL_LENS_FOCAL_NEAR: ENUM_PTZCMD = 25;
pub const ENUM_PTZCMD_AVIOCTRL_LENS_FOCAL_FAR: ENUM_PTZCMD = 26;
pub const ENUM_PTZCMD_AVIOCTRL_AUTO_PAN_SPEED: ENUM_PTZCMD = 27;
pub const ENUM_PTZCMD_AVIOCTRL_AUTO_PAN_LIMIT: ENUM_PTZCMD = 28;
pub const ENUM_PTZCMD_AVIOCTRL_AUTO_PAN_START: ENUM_PTZCMD = 29;
pub const ENUM_PTZCMD_AVIOCTRL_PATTERN_START: ENUM_PTZCMD = 30;
pub const ENUM_PTZCMD_AVIOCTRL_PATTERN_STOP: ENUM_PTZCMD = 31;
pub const ENUM_PTZCMD_AVIOCTRL_PATTERN_RUN: ENUM_PTZCMD = 32;
pub const ENUM_PTZCMD_AVIOCTRL_SET_AUX: ENUM_PTZCMD = 33;
pub const ENUM_PTZCMD_AVIOCTRL_CLEAR_AUX: ENUM_PTZCMD = 34;
pub const ENUM_PTZCMD_AVIOCTRL_MOTOR_RESET_POSITION: ENUM_PTZCMD = 35;
pub type ENUM_PTZCMD = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlAVStream {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlAVStream() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlAVStream>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlAVStream))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlAVStream>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlAVStream))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlAVStream>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlAVStream),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlAVStream>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlAVStream),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetStreamCtrlReq {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetStreamCtrlReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetStreamCtrlReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetStreamCtrlReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetStreamCtrlReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetStreamCtrlReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetStreamCtrlReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetStreamCtrlReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetStreamCtrlReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetStreamCtrlReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetStreamCtrlReq {
    pub channel: ::std::os::raw::c_uint,
    pub quality: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetStreamCtrlReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetStreamCtrlReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetStreamCtrlReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetStreamCtrlReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetStreamCtrlReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetStreamCtrlReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetStreamCtrlReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_quality() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetStreamCtrlReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetStreamCtrlReq),
                "::",
                stringify!(quality)
            )
        );
    }
    test_field_quality();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetStreamCtrlReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetStreamCtrlReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type SMsgAVIoctrlGetStreamCtrlResq = SMsgAVIoctrlSetStreamCtrlReq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetStreamCtrlResp {
    pub result: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetStreamCtrlResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetStreamCtrlResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetStreamCtrlResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetStreamCtrlResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetStreamCtrlResp))
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetStreamCtrlResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetStreamCtrlResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetStreamCtrlResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetStreamCtrlResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetMotionDetectReq {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetMotionDetectReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetMotionDetectReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetMotionDetectReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetMotionDetectReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetMotionDetectReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetMotionDetectReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetMotionDetectReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetMotionDetectReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetMotionDetectReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetMotionDetectReq {
    pub channel: ::std::os::raw::c_uint,
    pub sensitivity: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetMotionDetectReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetMotionDetectReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetMotionDetectReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetMotionDetectReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetMotionDetectReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetMotionDetectReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetMotionDetectReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_sensitivity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetMotionDetectReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sensitivity) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetMotionDetectReq),
                "::",
                stringify!(sensitivity)
            )
        );
    }
    test_field_sensitivity();
}
pub type SMsgAVIoctrlGetMotionDetectResp = SMsgAVIoctrlSetMotionDetectReq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetMotionDetectResp {
    pub result: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetMotionDetectResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetMotionDetectResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetMotionDetectResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetMotionDetectResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetMotionDetectResp))
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetMotionDetectResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetMotionDetectResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetMotionDetectResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetMotionDetectResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlDeviceInfoReq {
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlDeviceInfoReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlDeviceInfoReq>(),
        4usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlDeviceInfoReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlDeviceInfoReq>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlDeviceInfoReq))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlDeviceInfoResp {
    pub model: [::std::os::raw::c_uchar; 16usize],
    pub vendor: [::std::os::raw::c_uchar; 16usize],
    pub version: ::std::os::raw::c_uint,
    pub channel: ::std::os::raw::c_uint,
    pub total: ::std::os::raw::c_uint,
    pub free: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlDeviceInfoResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlDeviceInfoResp>(),
        56usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlDeviceInfoResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlDeviceInfoResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlDeviceInfoResp))
    );
    fn test_field_model() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).model) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoResp),
                "::",
                stringify!(model)
            )
        );
    }
    test_field_model();
    fn test_field_vendor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoResp),
                "::",
                stringify!(vendor)
            )
        );
    }
    test_field_vendor();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoResp),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoResp),
                "::",
                stringify!(total)
            )
        );
    }
    test_field_total();
    fn test_field_free() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoResp),
                "::",
                stringify!(free)
            )
        );
    }
    test_field_free();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlDeviceInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlDeviceInfoResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetPasswdReq {
    pub oldpasswd: [::std::os::raw::c_char; 32usize],
    pub newpasswd: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetPasswdReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetPasswdReq>(),
        64usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetPasswdReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetPasswdReq>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetPasswdReq))
    );
    fn test_field_oldpasswd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetPasswdReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).oldpasswd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetPasswdReq),
                "::",
                stringify!(oldpasswd)
            )
        );
    }
    test_field_oldpasswd();
    fn test_field_newpasswd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetPasswdReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).newpasswd) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetPasswdReq),
                "::",
                stringify!(newpasswd)
            )
        );
    }
    test_field_newpasswd();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetPasswdResp {
    pub result: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetPasswdResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetPasswdResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetPasswdResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetPasswdResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetPasswdResp))
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetPasswdResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetPasswdResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetPasswdResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetPasswdResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlListWifiApReq {
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlListWifiApReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlListWifiApReq>(),
        4usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlListWifiApReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlListWifiApReq>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlListWifiApReq))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListWifiApReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListWifiApReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SWifiAp {
    pub ssid: [::std::os::raw::c_char; 32usize],
    pub mode: ::std::os::raw::c_char,
    pub enctype: ::std::os::raw::c_char,
    pub signal: ::std::os::raw::c_char,
    pub status: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SWifiAp() {
    assert_eq!(
        ::std::mem::size_of::<SWifiAp>(),
        36usize,
        concat!("Size of: ", stringify!(SWifiAp))
    );
    assert_eq!(
        ::std::mem::align_of::<SWifiAp>(),
        1usize,
        concat!("Alignment of ", stringify!(SWifiAp))
    );
    fn test_field_ssid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SWifiAp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SWifiAp),
                "::",
                stringify!(ssid)
            )
        );
    }
    test_field_ssid();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SWifiAp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SWifiAp),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_enctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SWifiAp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enctype) as usize - ptr as usize
            },
            33usize,
            concat!(
                "Offset of field: ",
                stringify!(SWifiAp),
                "::",
                stringify!(enctype)
            )
        );
    }
    test_field_enctype();
    fn test_field_signal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SWifiAp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signal) as usize - ptr as usize
            },
            34usize,
            concat!(
                "Offset of field: ",
                stringify!(SWifiAp),
                "::",
                stringify!(signal)
            )
        );
    }
    test_field_signal();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SWifiAp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            35usize,
            concat!(
                "Offset of field: ",
                stringify!(SWifiAp),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlListWifiApResp {
    pub number: ::std::os::raw::c_uint,
    pub stWifiAp: [SWifiAp; 1usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlListWifiApResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlListWifiApResp>(),
        40usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlListWifiApResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlListWifiApResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlListWifiApResp))
    );
    fn test_field_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListWifiApResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).number) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListWifiApResp),
                "::",
                stringify!(number)
            )
        );
    }
    test_field_number();
    fn test_field_stWifiAp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListWifiApResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stWifiAp) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListWifiApResp),
                "::",
                stringify!(stWifiAp)
            )
        );
    }
    test_field_stWifiAp();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetWifiReq {
    pub ssid: [::std::os::raw::c_uchar; 32usize],
    pub password: [::std::os::raw::c_uchar; 32usize],
    pub mode: ::std::os::raw::c_uchar,
    pub enctype: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetWifiReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetWifiReq>(),
        76usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetWifiReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetWifiReq>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetWifiReq))
    );
    fn test_field_ssid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq),
                "::",
                stringify!(ssid)
            )
        );
    }
    test_field_ssid();
    fn test_field_password() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq),
                "::",
                stringify!(password)
            )
        );
    }
    test_field_password();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_enctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enctype) as usize - ptr as usize
            },
            65usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq),
                "::",
                stringify!(enctype)
            )
        );
    }
    test_field_enctype();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            66usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetWifiReq2 {
    pub ssid: [::std::os::raw::c_uchar; 32usize],
    pub password: [::std::os::raw::c_uchar; 64usize],
    pub mode: ::std::os::raw::c_uchar,
    pub enctype: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetWifiReq2() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetWifiReq2>(),
        108usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetWifiReq2))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetWifiReq2>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetWifiReq2))
    );
    fn test_field_ssid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq2),
                "::",
                stringify!(ssid)
            )
        );
    }
    test_field_ssid();
    fn test_field_password() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq2),
                "::",
                stringify!(password)
            )
        );
    }
    test_field_password();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq2),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_enctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enctype) as usize - ptr as usize
            },
            97usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq2),
                "::",
                stringify!(enctype)
            )
        );
    }
    test_field_enctype();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiReq2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            98usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiReq2),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetWifiResp {
    pub result: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetWifiResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetWifiResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetWifiResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetWifiResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetWifiResp))
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetWifiResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetWifiReq {
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetWifiReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetWifiReq>(),
        4usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetWifiReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetWifiReq>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetWifiReq))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetWifiResp {
    pub ssid: [::std::os::raw::c_uchar; 32usize],
    pub password: [::std::os::raw::c_uchar; 32usize],
    pub mode: ::std::os::raw::c_uchar,
    pub enctype: ::std::os::raw::c_uchar,
    pub signal: ::std::os::raw::c_uchar,
    pub status: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetWifiResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetWifiResp>(),
        68usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetWifiResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetWifiResp>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetWifiResp))
    );
    fn test_field_ssid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp),
                "::",
                stringify!(ssid)
            )
        );
    }
    test_field_ssid();
    fn test_field_password() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp),
                "::",
                stringify!(password)
            )
        );
    }
    test_field_password();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_enctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enctype) as usize - ptr as usize
            },
            65usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp),
                "::",
                stringify!(enctype)
            )
        );
    }
    test_field_enctype();
    fn test_field_signal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signal) as usize - ptr as usize
            },
            66usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp),
                "::",
                stringify!(signal)
            )
        );
    }
    test_field_signal();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            67usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetWifiResp2 {
    pub ssid: [::std::os::raw::c_uchar; 32usize],
    pub password: [::std::os::raw::c_uchar; 64usize],
    pub mode: ::std::os::raw::c_uchar,
    pub enctype: ::std::os::raw::c_uchar,
    pub signal: ::std::os::raw::c_uchar,
    pub status: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetWifiResp2() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetWifiResp2>(),
        100usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetWifiResp2))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetWifiResp2>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetWifiResp2))
    );
    fn test_field_ssid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ssid) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp2),
                "::",
                stringify!(ssid)
            )
        );
    }
    test_field_ssid();
    fn test_field_password() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp2),
                "::",
                stringify!(password)
            )
        );
    }
    test_field_password();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp2),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_enctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enctype) as usize - ptr as usize
            },
            97usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp2),
                "::",
                stringify!(enctype)
            )
        );
    }
    test_field_enctype();
    fn test_field_signal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).signal) as usize - ptr as usize
            },
            98usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp2),
                "::",
                stringify!(signal)
            )
        );
    }
    test_field_signal();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetWifiResp2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            99usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetWifiResp2),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetRecordReq {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetRecordReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetRecordReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetRecordReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetRecordReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetRecordReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetRecordReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetRecordReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetRecordReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetRecordReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetRecordReq {
    pub channel: ::std::os::raw::c_uint,
    pub recordType: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetRecordReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetRecordReq>(),
        12usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetRecordReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetRecordReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetRecordReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRecordReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRecordReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_recordType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRecordReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recordType) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRecordReq),
                "::",
                stringify!(recordType)
            )
        );
    }
    test_field_recordType();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRecordReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRecordReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
pub type SMsgAVIoctrlGetRecordResq = SMsgAVIoctrlSetRecordReq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetRecordResp {
    pub result: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetRecordResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetRecordResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetRecordResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetRecordResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetRecordResp))
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRecordResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRecordResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRecordResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRecordResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetRcdDurationReq {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetRcdDurationReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetRcdDurationReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetRcdDurationReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetRcdDurationReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetRcdDurationReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetRcdDurationReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetRcdDurationReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetRcdDurationReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetRcdDurationReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetRcdDurationReq {
    pub channel: ::std::os::raw::c_uint,
    pub presecond: ::std::os::raw::c_uint,
    pub durasecond: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetRcdDurationReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetRcdDurationReq>(),
        12usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetRcdDurationReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetRcdDurationReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetRcdDurationReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRcdDurationReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRcdDurationReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_presecond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRcdDurationReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).presecond) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRcdDurationReq),
                "::",
                stringify!(presecond)
            )
        );
    }
    test_field_presecond();
    fn test_field_durasecond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRcdDurationReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).durasecond) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRcdDurationReq),
                "::",
                stringify!(durasecond)
            )
        );
    }
    test_field_durasecond();
}
pub type SMsgAVIoctrlGetRcdDurationResp = SMsgAVIoctrlSetRcdDurationReq;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetRcdDurationResp {
    pub result: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetRcdDurationResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetRcdDurationResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetRcdDurationResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetRcdDurationResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetRcdDurationResp))
    );
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRcdDurationResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRcdDurationResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetRcdDurationResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetRcdDurationResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STimeDay {
    pub year: ::std::os::raw::c_ushort,
    pub month: ::std::os::raw::c_uchar,
    pub day: ::std::os::raw::c_uchar,
    pub wday: ::std::os::raw::c_uchar,
    pub hour: ::std::os::raw::c_uchar,
    pub minute: ::std::os::raw::c_uchar,
    pub second: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_STimeDay() {
    assert_eq!(
        ::std::mem::size_of::<STimeDay>(),
        8usize,
        concat!("Size of: ", stringify!(STimeDay))
    );
    assert_eq!(
        ::std::mem::align_of::<STimeDay>(),
        2usize,
        concat!("Alignment of ", stringify!(STimeDay))
    );
    fn test_field_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STimeDay>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(STimeDay),
                "::",
                stringify!(year)
            )
        );
    }
    test_field_year();
    fn test_field_month() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STimeDay>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(STimeDay),
                "::",
                stringify!(month)
            )
        );
    }
    test_field_month();
    fn test_field_day() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STimeDay>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(STimeDay),
                "::",
                stringify!(day)
            )
        );
    }
    test_field_day();
    fn test_field_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STimeDay>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wday) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(STimeDay),
                "::",
                stringify!(wday)
            )
        );
    }
    test_field_wday();
    fn test_field_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STimeDay>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(STimeDay),
                "::",
                stringify!(hour)
            )
        );
    }
    test_field_hour();
    fn test_field_minute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STimeDay>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minute) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(STimeDay),
                "::",
                stringify!(minute)
            )
        );
    }
    test_field_minute();
    fn test_field_second() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<STimeDay>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).second) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(STimeDay),
                "::",
                stringify!(second)
            )
        );
    }
    test_field_second();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlListEventReq {
    pub channel: ::std::os::raw::c_uint,
    pub stStartTime: STimeDay,
    pub stEndTime: STimeDay,
    pub event: ::std::os::raw::c_uchar,
    pub status: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlListEventReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlListEventReq>(),
        24usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlListEventReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlListEventReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlListEventReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_stStartTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stStartTime) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventReq),
                "::",
                stringify!(stStartTime)
            )
        );
    }
    test_field_stStartTime();
    fn test_field_stEndTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stEndTime) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventReq),
                "::",
                stringify!(stEndTime)
            )
        );
    }
    test_field_stEndTime();
    fn test_field_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventReq),
                "::",
                stringify!(event)
            )
        );
    }
    test_field_event();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            21usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventReq),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SAvEvent {
    pub stTime: STimeDay,
    pub event: ::std::os::raw::c_uchar,
    pub status: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout_SAvEvent() {
    assert_eq!(
        ::std::mem::size_of::<SAvEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SAvEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SAvEvent>(),
        2usize,
        concat!("Alignment of ", stringify!(SAvEvent))
    );
    fn test_field_stTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SAvEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stTime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SAvEvent),
                "::",
                stringify!(stTime)
            )
        );
    }
    test_field_stTime();
    fn test_field_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SAvEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SAvEvent),
                "::",
                stringify!(event)
            )
        );
    }
    test_field_event();
    fn test_field_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SAvEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(SAvEvent),
                "::",
                stringify!(status)
            )
        );
    }
    test_field_status();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SAvEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(SAvEvent),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlListEventResp {
    pub channel: ::std::os::raw::c_uint,
    pub total: ::std::os::raw::c_uint,
    pub index: ::std::os::raw::c_uchar,
    pub endflag: ::std::os::raw::c_uchar,
    pub count: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 1usize],
    pub stEvent: [SAvEvent; 1usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlListEventResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlListEventResp>(),
        24usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlListEventResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlListEventResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlListEventResp))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_total() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventResp),
                "::",
                stringify!(total)
            )
        );
    }
    test_field_total();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventResp),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_endflag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).endflag) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventResp),
                "::",
                stringify!(endflag)
            )
        );
    }
    test_field_endflag();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventResp),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
    fn test_field_stEvent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlListEventResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stEvent) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlListEventResp),
                "::",
                stringify!(stEvent)
            )
        );
    }
    test_field_stEvent();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlPlayRecord {
    pub channel: ::std::os::raw::c_uint,
    pub command: ::std::os::raw::c_uint,
    pub Param: ::std::os::raw::c_uint,
    pub stTimeDay: STimeDay,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlPlayRecord() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlPlayRecord>(),
        24usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlPlayRecord))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlPlayRecord>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlPlayRecord))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecord),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_command() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).command) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecord),
                "::",
                stringify!(command)
            )
        );
    }
    test_field_command();
    fn test_field_Param() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Param) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecord),
                "::",
                stringify!(Param)
            )
        );
    }
    test_field_Param();
    fn test_field_stTimeDay() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stTimeDay) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecord),
                "::",
                stringify!(stTimeDay)
            )
        );
    }
    test_field_stTimeDay();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecord),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlPlayRecordResp {
    pub command: ::std::os::raw::c_uint,
    pub result: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlPlayRecordResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlPlayRecordResp>(),
        12usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlPlayRecordResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlPlayRecordResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlPlayRecordResp))
    );
    fn test_field_command() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecordResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).command) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecordResp),
                "::",
                stringify!(command)
            )
        );
    }
    test_field_command();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecordResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecordResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPlayRecordResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPlayRecordResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlPtzCmd {
    pub control: ::std::os::raw::c_uchar,
    pub speed: ::std::os::raw::c_uchar,
    pub point: ::std::os::raw::c_uchar,
    pub limit: ::std::os::raw::c_uchar,
    pub aux: ::std::os::raw::c_uchar,
    pub channel: ::std::os::raw::c_uchar,
    pub reserve: [::std::os::raw::c_uchar; 2usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlPtzCmd() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlPtzCmd>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlPtzCmd))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlPtzCmd>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlPtzCmd))
    );
    fn test_field_control() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPtzCmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).control) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPtzCmd),
                "::",
                stringify!(control)
            )
        );
    }
    test_field_control();
    fn test_field_speed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPtzCmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPtzCmd),
                "::",
                stringify!(speed)
            )
        );
    }
    test_field_speed();
    fn test_field_point() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPtzCmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).point) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPtzCmd),
                "::",
                stringify!(point)
            )
        );
    }
    test_field_point();
    fn test_field_limit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPtzCmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).limit) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPtzCmd),
                "::",
                stringify!(limit)
            )
        );
    }
    test_field_limit();
    fn test_field_aux() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPtzCmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPtzCmd),
                "::",
                stringify!(aux)
            )
        );
    }
    test_field_aux();
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPtzCmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPtzCmd),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserve() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlPtzCmd>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserve) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlPtzCmd),
                "::",
                stringify!(reserve)
            )
        );
    }
    test_field_reserve();
}
#[doc = " @struct SMsgAVIoctrlEvent"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlEvent {
    pub stTime: STimeDay,
    pub time: ::std::os::raw::c_ulong,
    pub channel: ::std::os::raw::c_uint,
    pub event: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlEvent() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlEvent))
    );
    fn test_field_stTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stTime) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlEvent),
                "::",
                stringify!(stTime)
            )
        );
    }
    test_field_stTime();
    fn test_field_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlEvent),
                "::",
                stringify!(time)
            )
        );
    }
    test_field_time();
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlEvent),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlEvent),
                "::",
                stringify!(event)
            )
        );
    }
    test_field_event();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlEvent>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlEvent),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetEnvironmentReq {
    pub channel: ::std::os::raw::c_uint,
    pub mode: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetEnvironmentReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetEnvironmentReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetEnvironmentReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetEnvironmentReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetEnvironmentReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetEnvironmentReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetEnvironmentReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetEnvironmentReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetEnvironmentReq),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetEnvironmentReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetEnvironmentReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetEnvironmentResp {
    pub channel: ::std::os::raw::c_uint,
    pub result: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetEnvironmentResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetEnvironmentResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetEnvironmentResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetEnvironmentResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetEnvironmentResp))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetEnvironmentResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetEnvironmentResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetEnvironmentResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetEnvironmentResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetEnvironmentResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetEnvironmentResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetEnvironmentReq {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetEnvironmentReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetEnvironmentReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetEnvironmentReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetEnvironmentReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetEnvironmentReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetEnvironmentReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetEnvironmentReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetEnvironmentReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetEnvironmentReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetEnvironmentResp {
    pub channel: ::std::os::raw::c_uint,
    pub mode: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetEnvironmentResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetEnvironmentResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetEnvironmentResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetEnvironmentResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetEnvironmentResp))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetEnvironmentResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetEnvironmentResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetEnvironmentResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetEnvironmentResp),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetEnvironmentResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetEnvironmentResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetVideoModeReq {
    pub channel: ::std::os::raw::c_uint,
    pub mode: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetVideoModeReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetVideoModeReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetVideoModeReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetVideoModeReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetVideoModeReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetVideoModeReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetVideoModeReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetVideoModeReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetVideoModeReq),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetVideoModeReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetVideoModeReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetVideoModeResp {
    pub channel: ::std::os::raw::c_uint,
    pub result: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetVideoModeResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetVideoModeResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetVideoModeResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetVideoModeResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetVideoModeResp))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetVideoModeResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetVideoModeResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetVideoModeResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetVideoModeResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetVideoModeResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetVideoModeResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetVideoModeReq {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetVideoModeReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetVideoModeReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetVideoModeReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetVideoModeReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetVideoModeReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetVideoModeReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetVideoModeReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetVideoModeReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetVideoModeReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetVideoModeResp {
    pub channel: ::std::os::raw::c_uint,
    pub mode: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetVideoModeResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetVideoModeResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetVideoModeResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetVideoModeResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetVideoModeResp))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetVideoModeResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetVideoModeResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetVideoModeResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetVideoModeResp),
                "::",
                stringify!(mode)
            )
        );
    }
    test_field_mode();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetVideoModeResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetVideoModeResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlFormatExtStorageReq {
    pub storage: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlFormatExtStorageReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlFormatExtStorageReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlFormatExtStorageReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlFormatExtStorageReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlFormatExtStorageReq))
    );
    fn test_field_storage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlFormatExtStorageReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlFormatExtStorageReq),
                "::",
                stringify!(storage)
            )
        );
    }
    test_field_storage();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlFormatExtStorageReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlFormatExtStorageReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlFormatExtStorageResp {
    pub storage: ::std::os::raw::c_uint,
    pub result: ::std::os::raw::c_uchar,
    pub reserved: [::std::os::raw::c_uchar; 3usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlFormatExtStorageResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlFormatExtStorageResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlFormatExtStorageResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlFormatExtStorageResp>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SMsgAVIoctrlFormatExtStorageResp)
        )
    );
    fn test_field_storage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlFormatExtStorageResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlFormatExtStorageResp),
                "::",
                stringify!(storage)
            )
        );
    }
    test_field_storage();
    fn test_field_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlFormatExtStorageResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).result) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlFormatExtStorageResp),
                "::",
                stringify!(result)
            )
        );
    }
    test_field_result();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlFormatExtStorageResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlFormatExtStorageResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SStreamDef {
    pub index: ::std::os::raw::c_ushort,
    pub channel: ::std::os::raw::c_ushort,
    pub reserved: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_SStreamDef() {
    assert_eq!(
        ::std::mem::size_of::<SStreamDef>(),
        8usize,
        concat!("Size of: ", stringify!(SStreamDef))
    );
    assert_eq!(
        ::std::mem::align_of::<SStreamDef>(),
        2usize,
        concat!("Alignment of ", stringify!(SStreamDef))
    );
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SStreamDef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SStreamDef),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SStreamDef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(SStreamDef),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SStreamDef>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SStreamDef),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetSupportStreamReq {
    pub reserved: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetSupportStreamReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetSupportStreamReq>(),
        4usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetSupportStreamReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetSupportStreamReq>(),
        1usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetSupportStreamReq))
    );
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetSupportStreamReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetSupportStreamReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetSupportStreamResp {
    pub number: ::std::os::raw::c_uint,
    pub streams: [SStreamDef; 1usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetSupportStreamResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetSupportStreamResp>(),
        12usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetSupportStreamResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetSupportStreamResp>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SMsgAVIoctrlGetSupportStreamResp)
        )
    );
    fn test_field_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetSupportStreamResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).number) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetSupportStreamResp),
                "::",
                stringify!(number)
            )
        );
    }
    test_field_number();
    fn test_field_streams() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetSupportStreamResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).streams) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetSupportStreamResp),
                "::",
                stringify!(streams)
            )
        );
    }
    test_field_streams();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetAudioOutFormatReq {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetAudioOutFormatReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetAudioOutFormatReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetAudioOutFormatReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetAudioOutFormatReq>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SMsgAVIoctrlGetAudioOutFormatReq)
        )
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetAudioOutFormatReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetAudioOutFormatReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetAudioOutFormatReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetAudioOutFormatReq),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetAudioOutFormatResp {
    pub channel: ::std::os::raw::c_uint,
    pub format: ::std::os::raw::c_int,
    pub reserved: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetAudioOutFormatResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetAudioOutFormatResp>(),
        12usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetAudioOutFormatResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetAudioOutFormatResp>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SMsgAVIoctrlGetAudioOutFormatResp)
        )
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetAudioOutFormatResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetAudioOutFormatResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_format() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetAudioOutFormatResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetAudioOutFormatResp),
                "::",
                stringify!(format)
            )
        );
    }
    test_field_format();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetAudioOutFormatResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetAudioOutFormatResp),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlReceiveFirstIFrame {
    pub channel: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlReceiveFirstIFrame() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlReceiveFirstIFrame>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlReceiveFirstIFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlReceiveFirstIFrame>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlReceiveFirstIFrame))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlReceiveFirstIFrame>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlReceiveFirstIFrame),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlReceiveFirstIFrame>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlReceiveFirstIFrame),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetFlowInfoReq {
    pub channel: ::std::os::raw::c_uint,
    pub collect_interval: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetFlowInfoReq() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetFlowInfoReq>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetFlowInfoReq))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetFlowInfoReq>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetFlowInfoReq))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetFlowInfoReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetFlowInfoReq),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_collect_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetFlowInfoReq>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).collect_interval) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetFlowInfoReq),
                "::",
                stringify!(collect_interval)
            )
        );
    }
    test_field_collect_interval();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetFlowInfoResp {
    pub channel: ::std::os::raw::c_uint,
    pub collect_interval: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetFlowInfoResp() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetFlowInfoResp>(),
        8usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetFlowInfoResp))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetFlowInfoResp>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetFlowInfoResp))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetFlowInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetFlowInfoResp),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_collect_interval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetFlowInfoResp>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).collect_interval) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetFlowInfoResp),
                "::",
                stringify!(collect_interval)
            )
        );
    }
    test_field_collect_interval();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlCurrentFlowInfo {
    pub channel: ::std::os::raw::c_uint,
    pub total_frame_count: ::std::os::raw::c_uint,
    pub lost_incomplete_frame_count: ::std::os::raw::c_uint,
    pub total_expected_frame_size: ::std::os::raw::c_uint,
    pub total_actual_frame_size: ::std::os::raw::c_uint,
    pub timestamp_ms: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlCurrentFlowInfo() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlCurrentFlowInfo>(),
        32usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlCurrentFlowInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlCurrentFlowInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlCurrentFlowInfo))
    );
    fn test_field_channel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlCurrentFlowInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlCurrentFlowInfo),
                "::",
                stringify!(channel)
            )
        );
    }
    test_field_channel();
    fn test_field_total_frame_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlCurrentFlowInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_frame_count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlCurrentFlowInfo),
                "::",
                stringify!(total_frame_count)
            )
        );
    }
    test_field_total_frame_count();
    fn test_field_lost_incomplete_frame_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlCurrentFlowInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lost_incomplete_frame_count) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlCurrentFlowInfo),
                "::",
                stringify!(lost_incomplete_frame_count)
            )
        );
    }
    test_field_lost_incomplete_frame_count();
    fn test_field_total_expected_frame_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlCurrentFlowInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_expected_frame_size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlCurrentFlowInfo),
                "::",
                stringify!(total_expected_frame_size)
            )
        );
    }
    test_field_total_expected_frame_size();
    fn test_field_total_actual_frame_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlCurrentFlowInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_actual_frame_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlCurrentFlowInfo),
                "::",
                stringify!(total_actual_frame_size)
            )
        );
    }
    test_field_total_actual_frame_size();
    fn test_field_timestamp_ms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlCurrentFlowInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).timestamp_ms) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlCurrentFlowInfo),
                "::",
                stringify!(timestamp_ms)
            )
        );
    }
    test_field_timestamp_ms();
    fn test_field_reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlCurrentFlowInfo>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlCurrentFlowInfo),
                "::",
                stringify!(reserved)
            )
        );
    }
    test_field_reserved();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlTimeZone {
    pub cbSize: ::std::os::raw::c_int,
    pub nIsSupportTimeZone: ::std::os::raw::c_int,
    pub nGMTDiff: ::std::os::raw::c_int,
    pub szTimeZoneString: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlTimeZone() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlTimeZone>(),
        268usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlTimeZone))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlTimeZone>(),
        4usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlTimeZone))
    );
    fn test_field_cbSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlTimeZone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlTimeZone),
                "::",
                stringify!(cbSize)
            )
        );
    }
    test_field_cbSize();
    fn test_field_nIsSupportTimeZone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlTimeZone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nIsSupportTimeZone) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlTimeZone),
                "::",
                stringify!(nIsSupportTimeZone)
            )
        );
    }
    test_field_nIsSupportTimeZone();
    fn test_field_nGMTDiff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlTimeZone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nGMTDiff) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlTimeZone),
                "::",
                stringify!(nGMTDiff)
            )
        );
    }
    test_field_nGMTDiff();
    fn test_field_szTimeZoneString() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlTimeZone>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szTimeZoneString) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlTimeZone),
                "::",
                stringify!(szTimeZoneString)
            )
        );
    }
    test_field_szTimeZoneString();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlGetDropbox {
    pub nSupportDropbox: ::std::os::raw::c_ushort,
    pub nLinked: ::std::os::raw::c_ushort,
    pub szLinkUDID: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlGetDropbox() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlGetDropbox>(),
        68usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlGetDropbox))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlGetDropbox>(),
        2usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlGetDropbox))
    );
    fn test_field_nSupportDropbox() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nSupportDropbox) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetDropbox),
                "::",
                stringify!(nSupportDropbox)
            )
        );
    }
    test_field_nSupportDropbox();
    fn test_field_nLinked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nLinked) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetDropbox),
                "::",
                stringify!(nLinked)
            )
        );
    }
    test_field_nLinked();
    fn test_field_szLinkUDID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlGetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szLinkUDID) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlGetDropbox),
                "::",
                stringify!(szLinkUDID)
            )
        );
    }
    test_field_szLinkUDID();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SMsgAVIoctrlSetDropbox {
    pub nLinked: ::std::os::raw::c_ushort,
    pub szLinkUDID: [::std::os::raw::c_char; 64usize],
    pub szAccessToken: [::std::os::raw::c_char; 128usize],
    pub szAccessTokenSecret: [::std::os::raw::c_char; 128usize],
    pub szAppKey: [::std::os::raw::c_char; 128usize],
    pub szSecret: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_SMsgAVIoctrlSetDropbox() {
    assert_eq!(
        ::std::mem::size_of::<SMsgAVIoctrlSetDropbox>(),
        578usize,
        concat!("Size of: ", stringify!(SMsgAVIoctrlSetDropbox))
    );
    assert_eq!(
        ::std::mem::align_of::<SMsgAVIoctrlSetDropbox>(),
        2usize,
        concat!("Alignment of ", stringify!(SMsgAVIoctrlSetDropbox))
    );
    fn test_field_nLinked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).nLinked) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetDropbox),
                "::",
                stringify!(nLinked)
            )
        );
    }
    test_field_nLinked();
    fn test_field_szLinkUDID() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szLinkUDID) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetDropbox),
                "::",
                stringify!(szLinkUDID)
            )
        );
    }
    test_field_szLinkUDID();
    fn test_field_szAccessToken() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szAccessToken) as usize - ptr as usize
            },
            66usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetDropbox),
                "::",
                stringify!(szAccessToken)
            )
        );
    }
    test_field_szAccessToken();
    fn test_field_szAccessTokenSecret() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szAccessTokenSecret) as usize - ptr as usize
            },
            194usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetDropbox),
                "::",
                stringify!(szAccessTokenSecret)
            )
        );
    }
    test_field_szAccessTokenSecret();
    fn test_field_szAppKey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szAppKey) as usize - ptr as usize
            },
            322usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetDropbox),
                "::",
                stringify!(szAppKey)
            )
        );
    }
    test_field_szAppKey();
    fn test_field_szSecret() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SMsgAVIoctrlSetDropbox>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).szSecret) as usize - ptr as usize
            },
            450usize,
            concat!(
                "Offset of field: ",
                stringify!(SMsgAVIoctrlSetDropbox),
                "::",
                stringify!(szSecret)
            )
        );
    }
    test_field_szSecret();
}
